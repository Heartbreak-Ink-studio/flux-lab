<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Apollo × Flux | Velvet Interface</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Courier New', Courier, monospace; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: rgba(0, 0, 0, 0.85); color: #fff; z-index: 10;
            transition: opacity 0.5s ease;
        }
        #overlay.hidden { opacity: 0; pointer-events: none; }
        h1 { font-size: 2rem; letter-spacing: 0.2em; text-transform: uppercase; margin-bottom: 0.5rem; text-shadow: 0 0 10px #ff0055; }
        p { font-size: 0.9rem; opacity: 0.7; margin-bottom: 2rem; }
        button {
            background: transparent; border: 2px solid #ff0055; color: #ff0055;
            padding: 1rem 2rem; font-size: 1rem; text-transform: uppercase; letter-spacing: 0.1em;
            cursor: pointer; transition: all 0.3s ease;
        }
        button:hover { background: #ff0055; color: #fff; box-shadow: 0 0 20px #ff0055; }
        #ui-layer {
            position: absolute; bottom: 20px; left: 20px; color: #ff0055;
            font-size: 0.8rem; pointer-events: none; z-index: 5;
            text-shadow: 0 0 5px #ff0055;
        }
    </style>
</head>
<body>
    <div id="overlay">
        <h1>Velvet Interface</h1>
        <p>Audio Reactive Visualizer /// Apollo × Flux</p>
        <button id="start-btn">Initialize Sequence</button>
    </div>
    <div id="ui-layer">
        SESSION: VELVET_V2_POLISH<br>
        BPM: 116 (SYNCED)<br>
        FLUX STATE: ACTIVE
    </div>
    <div id="canvas-container"></div>

    <!-- Import Map for Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';

        // --- Configuration ---
        const CONFIG = {
            audioPath: './assets/audio/velvet-interface.mp3',
            fftSize: 2048,
            smoothing: 0.85,
            bars: 64,
            gridSize: 40,
            colorA: new THREE.Color(0xff0055), // Neon Pink
            colorB: new THREE.Color(0x00ffff), // Cyan
            bpm: 116
        };

        // --- Globals ---
        let scene, camera, renderer, composer, controls;
        let analyser, dataArray, audioContext, audioSource;
        let dancerMixer = null;
        let danceClips = [];
        let currentDanceAction = null;
        let activeAction = null;
        let geometryGroup = new THREE.Group();
        let bars = [];
        let particles;
        let dancer;
        let clock = new THREE.Clock();
        let isPlaying = false;
        
        // Dance State
        let lastBeatTime = 0;
        let beatCount = 0;
        const beatInterval = 60 / CONFIG.bpm;
        let currentClipIndex = 0;

        const startBtn = document.getElementById('start-btn');
        const overlay = document.getElementById('overlay');

        // --- Initialization ---
        function init() {
            // Scene Setup
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.02);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 4, 12); // Closer, more cinematic start

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Cap pixel ratio for perf
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Post-Processing (Bloom)
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.15;
            bloomPass.strength = 1.8; // Popping glow
            bloomPass.radius = 0.6;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.8;
            controls.maxPolarAngle = Math.PI / 2 - 0.1; // Don't go below floor
            controls.minDistance = 5;
            controls.maxDistance = 30;

            // Build World
            createFloorGrid();
            createFrequencyBars();
            createParticleField();
            createDancer();

            // Lights
            const ambientLight = new THREE.AmbientLight(0x202020);
            scene.add(ambientLight);
            
            // Key Light
            const spotLight = new THREE.SpotLight(CONFIG.colorA, 500);
            spotLight.position.set(10, 20, 10);
            spotLight.angle = 0.5;
            spotLight.penumbra = 0.5;
            spotLight.castShadow = true;
            spotLight.shadow.bias = -0.0001;
            scene.add(spotLight);
            
            // Rim Light
            const rimLight = new THREE.SpotLight(CONFIG.colorB, 800);
            rimLight.position.set(-10, 10, -10);
            rimLight.lookAt(0, 0, 0);
            scene.add(rimLight);

            // Events
            window.addEventListener('resize', onWindowResize);
            startBtn.addEventListener('click', startExperience);
        }

        // --- Audio Setup ---
        async function setupAudio() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            analyser.fftSize = CONFIG.fftSize;
            analyser.smoothingTimeConstant = CONFIG.smoothing;
            
            try {
                const response = await fetch(CONFIG.audioPath);
                const arrayBuffer = await response.arrayBuffer();
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

                const source = audioContext.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(analyser);
                analyser.connect(audioContext.destination);
                source.loop = true;
                source.start(0);
                
                dataArray = new Uint8Array(analyser.frequencyBinCount);
                isPlaying = true;
                
                overlay.classList.add('hidden');
            } catch (e) {
                console.error("Audio setup failed:", e);
                startBtn.innerText = "AUDIO ERROR - CHECK CONSOLE";
            }
        }

        function startExperience() {
            if (!isPlaying) {
                startBtn.innerText = "LOADING...";
                setupAudio();
            }
        }

        // --- World Building ---
        function createFloorGrid() {
            // Main Grid
            const gridHelper = new THREE.GridHelper(100, CONFIG.gridSize, CONFIG.colorA, 0x1a1a1a);
            gridHelper.position.y = -2;
            scene.add(gridHelper);
            
            // Reflective Floor Plane
            const geometry = new THREE.PlaneGeometry(200, 200);
            const material = new THREE.MeshStandardMaterial({ 
                color: 0x050505, 
                roughness: 0.1,
                metalness: 0.8,
                side: THREE.DoubleSide
            });
            const plane = new THREE.Mesh(geometry, material);
            plane.rotation.x = -Math.PI / 2;
            plane.position.y = -2.05;
            plane.receiveShadow = true;
            scene.add(plane);
        }

        function createFrequencyBars() {
            const geometry = new THREE.BoxGeometry(0.5, 1, 0.5);
            const count = CONFIG.bars;
            const radius = 12;

            for (let i = 0; i < count; i++) {
                const material = new THREE.MeshStandardMaterial({ 
                    color: CONFIG.colorB,
                    emissive: CONFIG.colorB,
                    emissiveIntensity: 0.5,
                    roughness: 0.1,
                    metalness: 0.8
                });
                
                const bar = new THREE.Mesh(geometry, material);
                
                const angle = (i / count) * Math.PI * 2;
                bar.position.x = Math.cos(angle) * radius;
                bar.position.z = Math.sin(angle) * radius;
                bar.position.y = -2; // Start at floor
                bar.rotation.y = -angle;
                
                bars.push(bar);
                geometryGroup.add(bar);
            }
            scene.add(geometryGroup);
        }

        function createParticleField() {
            const particleCount = 3000;
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const scales = [];
            
            for (let i = 0; i < particleCount; i++) {
                positions.push((Math.random() - 0.5) * 120); // x
                positions.push((Math.random() - 0.5) * 60 + 10);  // y
                positions.push((Math.random() - 0.5) * 120); // z
                scales.push(Math.random());
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('scale', new THREE.Float32BufferAttribute(scales, 1));
            
            const material = new THREE.PointsMaterial({ 
                color: 0xffffff, 
                size: 0.15, 
                transparent: true, 
                opacity: 0.6,
                blending: THREE.AdditiveBlending 
            });
            
            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        function createDancer() {
            const fbxLoader = new FBXLoader();
            // Using a mix of aggressive and smooth moves
            const danceFiles = [
                './assets/mixamo/hip-hop-dancing.fbx',
                './assets/mixamo/breakdance-footwork-1.fbx', 
                './assets/mixamo/breakdance-swipes.fbx',
                './assets/mixamo/flair.fbx',
                './assets/mixamo/breakdance-freezes.fbx'
            ];

            fbxLoader.load('./assets/mixamo/x-bot.fbx', (base) => {
                dancer = base;
                dancer.scale.setScalar(0.02);
                dancer.position.set(0, -2.0, 0);
                
                // Enhance Materials for Glow/Light Interaction
                dancer.traverse((obj) => {
                    if (obj.isMesh) {
                        obj.castShadow = true;
                        obj.receiveShadow = true;
                        // White matte finish with rim lighting capability
                        obj.material = new THREE.MeshStandardMaterial({
                            color: 0xffffff,
                            roughness: 0.4,
                            metalness: 0.1,
                            emissive: 0x222222,
                            emissiveIntensity: 0.2
                        });
                    }
                });

                scene.add(dancer);
                dancerMixer = new THREE.AnimationMixer(dancer);

                // Load all clips
                let loaded = 0;
                danceFiles.forEach((file) => {
                    fbxLoader.load(file, (animFbx) => {
                        const clip = animFbx.animations[0];
                        if (clip) {
                            danceClips.push(clip);
                        }
                        loaded++;
                        if (loaded === danceFiles.length) {
                            // Start first dance
                            if (danceClips.length > 0) {
                                activeAction = dancerMixer.clipAction(danceClips[0]);
                                activeAction.play();
                            }
                        }
                    });
                });
            }, undefined, (err) => {
                console.error("Error loading X-Bot, falling back", err);
                createFallbackDancer();
            });
        }
        
        // Simple fallback if X-Bot fails (kept from V1 but simplified)
        function createFallbackDancer() {
            const geometry = new THREE.CapsuleGeometry(1, 4, 4, 16);
            const material = new THREE.MeshStandardMaterial({ color: CONFIG.colorA, wireframe: true });
            dancer = new THREE.Mesh(geometry, material);
            dancer.position.y = 0;
            scene.add(dancer);
        }

        function fadeToNextDance() {
            if (danceClips.length < 2 || !dancerMixer) return;

            // Pick next clip
            const nextIndex = (currentClipIndex + 1) % danceClips.length;
            const nextClip = danceClips[nextIndex];
            
            const nextAction = dancerMixer.clipAction(nextClip);
            nextAction.reset();
            nextAction.play();
            
            // Crossfade
            if (activeAction) {
                activeAction.crossFadeTo(nextAction, 0.4, true);
            }
            
            activeAction = nextAction;
            currentClipIndex = nextIndex;
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();
            
            // Default levels
            let bassLevel = 0;
            let midLevel = 0;
            let highLevel = 0;

            if (isPlaying && analyser) {
                analyser.getByteFrequencyData(dataArray);
                
                // Frequency Bands (Standardized)
                // Bass: 0-10, Mid: 10-100, High: 100-255 (approx)
                let bassSum = 0;
                let midSum = 0;
                let highSum = 0;
                
                for (let i = 0; i < dataArray.length; i++) {
                    const val = dataArray[i];
                    if (i < 8) bassSum += val;
                    else if (i < 64) midSum += val;
                    else highSum += val;
                }
                
                bassLevel = (bassSum / 8) / 255;       // 0-1
                midLevel = (midSum / 56) / 255;        // 0-1
                highLevel = (highSum / (dataArray.length - 64)) / 255; // 0-1
                
                // Beat Detection & Quantized Switching
                if (bassLevel > 0.6 && (time - lastBeatTime) > (beatInterval * 0.8)) {
                    // Beat hit
                    lastBeatTime = time;
                    beatCount++;
                    
                    // Switch dance every 8 bars (32 beats)
                    if (beatCount > 0 && beatCount % 32 === 0) {
                        fadeToNextDance();
                    }
                    
                    // Pulse Camera FOV slightly on beat
                    camera.fov = 75 - (bassLevel * 2);
                    camera.updateProjectionMatrix();
                }

                // Update Bars
                bars.forEach((bar, i) => {
                    const dataIndex = Math.floor(i * (dataArray.length / CONFIG.bars) * 0.4); 
                    const value = dataArray[dataIndex] / 255;
                    
                    // More reactive scaling
                    const targetScale = 0.5 + (value * 25); 
                    bar.scale.y += (targetScale - bar.scale.y) * 0.3;
                    
                    // Anchor to floor
                    bar.position.y = (bar.scale.y / 2) - 2; 
                    
                    // Color gradient: Cyan (low) -> Pink (high)
                    const color = new THREE.Color().lerpColors(CONFIG.colorB, CONFIG.colorA, value * 1.5);
                    bar.material.color = color;
                    bar.material.emissiveIntensity = value * 4;
                });
                
                // Rotate Ring
                geometryGroup.rotation.y += 0.002 + (bassLevel * 0.02);
            }

            // Dancer Update
            if (dancerMixer) {
                dancerMixer.update(delta);
            }
            
            // Particle Drift
            if (particles) {
                particles.rotation.y = time * 0.03;
                particles.position.y = Math.sin(time * 0.5) * 2;
            }
            
            // Dynamic Camera Orbit
            // Slowly drift, speed up on high energy
            controls.autoRotateSpeed = 0.8 + (midLevel * 2.0);
            
            // Bloom Pulse
            if (composer) {
                composer.passes[1].strength = 1.2 + (bassLevel * 0.8);
            }

            controls.update();
            composer.render();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // Start
        init();
        animate();
    </script>
</body>
</html>
