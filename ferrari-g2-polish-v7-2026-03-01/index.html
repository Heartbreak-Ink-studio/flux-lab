<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Ferrari Commercial G2.5 v7 (Premium White)</title>
  <style>
    body { margin: 0; overflow: hidden; background: #050505; }
    #info { position: fixed; top: 12px; width: 100%; text-align: center; color: #888; font: 11px/1.2 "Helvetica Neue", Arial, sans-serif; letter-spacing: 3px; text-transform: uppercase; pointer-events: none; opacity: 0.7; }
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div id="info">Ferrari Commercial G2.5 v7 â€” Premium White Ceremony</div>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    // -- TEXTURE GENERATION --
    function createSkinNormal() {
      const size = 512;
      const canvas = document.createElement('canvas');
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = '#8080ff'; 
      ctx.fillRect(0, 0, size, size);
      
      const id = ctx.getImageData(0,0,size,size);
      const d = id.data;
      for(let i=0; i<d.length; i+=4){
        const noise = (Math.random() - 0.5) * 20; 
        d[i]   = Math.max(0, Math.min(255, d[i] + noise));     
        d[i+1] = Math.max(0, Math.min(255, d[i+1] + noise));   
        d[i+2] = 255; 
      }
      ctx.putImageData(id, 0, 0);
      const tex = new THREE.CanvasTexture(canvas);
      tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
      tex.colorSpace = THREE.NoColorSpace; 
      return tex;
    }

    function createMarbleTexture() {
      const size = 1024;
      const canvas = document.createElement('canvas');
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = '#1a1a1e'; 
      ctx.fillRect(0, 0, size, size);
      ctx.strokeStyle = '#333338';
      ctx.lineWidth = 2;
      for(let i=0; i<20; i++){
        ctx.beginPath();
        ctx.moveTo(Math.random()*size, Math.random()*size);
        ctx.bezierCurveTo(
            Math.random()*size, Math.random()*size,
            Math.random()*size, Math.random()*size,
            Math.random()*size, Math.random()*size
        );
        ctx.stroke();
      }
      const id = ctx.getImageData(0,0,size,size);
      const d = id.data;
      for(let i=0; i<d.length; i+=4){
        const val = (Math.random() - 0.5) * 10;
        d[i] += val; d[i+1] += val; d[i+2] += val;
      }
      ctx.putImageData(id, 0, 0);
      const tex = new THREE.CanvasTexture(canvas);
      tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
      tex.colorSpace = THREE.SRGBColorSpace;
      return tex;
    }

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x050505);
    scene.fog = new THREE.FogExp2(0x050505, 0.012); 

    const camera = new THREE.PerspectiveCamera(35, innerWidth / innerHeight, 0.1, 300);
    camera.position.set(5.5, 3.2, 8.5); 
    camera.lookAt(0, 1.2, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, stencil: false });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.3; 
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.maxPolarAngle = Math.PI / 2 - 0.05; 
    controls.target.set(0, 1.2, 0);

    // -- LIGHTING (White Guarantee) --
    const spot = new THREE.SpotLight(0xfff0e6, 4000, 80, Math.PI / 8, 0.5, 1.5);
    spot.position.set(5, 25, 5); 
    spot.target.position.set(0, 0, 0);
    spot.castShadow = true;
    spot.shadow.mapSize.set(2048, 2048);
    spot.shadow.bias = -0.0001;
    spot.shadow.radius = 4; 
    scene.add(spot);
    scene.add(spot.target);

    const hemi = new THREE.HemisphereLight(0xffffff, 0x222228, 1.2); 
    scene.add(hemi);

    const rim = new THREE.SpotLight(0xddeeff, 3000, 60, Math.PI / 6, 0.8, 1);
    rim.position.set(-10, 8, -10);
    rim.lookAt(0, 0, 0);
    scene.add(rim);

    // GUARANTEE: Front fill ensures no black silhouettes
    const safetyLight = new THREE.DirectionalLight(0xffffff, 1.5);
    safetyLight.position.set(2, 5, 10);
    scene.add(safetyLight);

    // -- ARCHITECTURE --
    const matFloor = new THREE.MeshStandardMaterial({
      color: 0x222222, 
      roughness: 0.1,  
      metalness: 0.4,
      map: createMarbleTexture()
    });
    matFloor.map.repeat.set(8, 8);
    
    const floor = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), matFloor);
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);

    const matStone = new THREE.MeshStandardMaterial({ 
      color: 0x333333, 
      roughness: 0.8,
      metalness: 0.1
    });
    
    const colGeo = new THREE.CylinderGeometry(1.2, 1.4, 40, 48);
    const colCount = 10;
    const colRadius = 22;
    
    const colGroup = new THREE.Group();
    for(let i=0; i<colCount; i++) {
        const a = (i/colCount) * Math.PI * 2;
        if(Math.abs(a - Math.PI/2) < 0.5) continue; 

        const c = new THREE.Mesh(colGeo, matStone);
        c.position.set(Math.cos(a)*colRadius, 20, Math.sin(a)*colRadius);
        c.castShadow = true;
        c.receiveShadow = true;
        colGroup.add(c);
        
        const base = new THREE.Mesh(new THREE.CylinderGeometry(1.8, 2.0, 1.5, 32), matStone);
        base.position.copy(c.position);
        base.position.y = 0.75;
        colGroup.add(base);
    }
    scene.add(colGroup);

    const beamGeo = new THREE.BoxGeometry(80, 1, 3);
    for(let k=0; k<5; k++) {
        const b = new THREE.Mesh(beamGeo, matStone);
        b.position.y = 30;
        b.rotation.y = (k/5) * Math.PI;
        b.receiveShadow = true;
        scene.add(b);
    }

    // -- TREADMILL --
    const treadmill = new THREE.Group();
    const tBase = new THREE.Mesh(
      new THREE.BoxGeometry(1.8, 0.2, 6.0), 
      new THREE.MeshStandardMaterial({ color: 0x050505, roughness: 0.4, metalness: 0.9 })
    );
    tBase.position.y = 0.1;
    tBase.receiveShadow = true;
    treadmill.add(tBase);
    
    const led = new THREE.Mesh(
        new THREE.BoxGeometry(1.85, 0.05, 6.05),
        new THREE.MeshBasicMaterial({ color: 0xff0000 })
    );
    led.position.y = 0.1;
    treadmill.add(led);

    const beltTex = new THREE.TextureLoader().load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/uv_grid_opengl.jpg');
    beltTex.wrapS = beltTex.wrapT = THREE.RepeatWrapping;
    beltTex.repeat.set(1, 10);
    beltTex.anisotropy = 16;
    
    const tBelt = new THREE.Mesh(
        new THREE.PlaneGeometry(1.4, 5.8),
        new THREE.MeshStandardMaterial({ 
            map: beltTex, 
            color: 0x222222, 
            roughness: 0.8,
            emissive: 0x111111,
            emissiveIntensity: 0.2
        })
    );
    tBelt.rotation.x = -Math.PI/2;
    tBelt.position.y = 0.22;
    treadmill.add(tBelt);
    scene.add(treadmill);

    // -- ASSETS --
    const loader = new GLTFLoader();
    const skinNormal = createSkinNormal();
    skinNormal.repeat.set(25, 25);

    let mixer = null;
    let horseMesh = null;

    loader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/models/gltf/Horse.glb', (gltf) => {
        horseMesh = gltf.scene.children[0];
        
        // PREMIUM WHITE MATERIAL + GUARANTEE
        const mat = new THREE.MeshStandardMaterial({
            color: 0xffffff,       
            emissive: 0x555555,    // Emissive floor = guarantee against black
            emissiveIntensity: 0.5,
            roughness: 0.4,        
            metalness: 0.1,        
            normalMap: skinNormal, 
            normalScale: new THREE.Vector2(0.5, 0.5)
        });

        horseMesh.material = mat;
        horseMesh.castShadow = true;
        horseMesh.receiveShadow = true;
        
        const s = 0.012; 
        horseMesh.scale.set(s, s, s);
        
        const horseGroup = new THREE.Group();
        horseGroup.add(horseMesh);
        horseGroup.rotation.y = Math.PI; 
        horseGroup.position.y = 0.22; 
        scene.add(horseGroup);
        
        mixer = new THREE.AnimationMixer(horseMesh);
        const action = mixer.clipAction(gltf.animations[0]);
        action.timeScale = 1.8;
        action.play();
    });

    // PROCEDURAL PREMIUM CHAIRS
    const chairGeo = new THREE.BoxGeometry(0.6, 0.08, 0.6); 
    const backGeo = new THREE.BoxGeometry(0.6, 0.5, 0.08);  
    const legGeo = new THREE.CylinderGeometry(0.03, 0.02, 0.45);
    
    const chairMat = new THREE.MeshStandardMaterial({ 
        color: 0x1a1a1a, 
        roughness: 0.3,
        metalness: 0.7 
    });
    
    function createChair() {
        const g = new THREE.Group();
        const seat = new THREE.Mesh(chairGeo, chairMat);
        seat.position.y = 0.45;
        seat.castShadow = true;
        seat.receiveShadow = true;
        g.add(seat);
        
        const back = new THREE.Mesh(backGeo, chairMat);
        back.position.set(0, 0.7, -0.28);
        back.castShadow = true;
        back.receiveShadow = true;
        g.add(back);
        
        const positions = [[0.25, 0.225, 0.25], [-0.25, 0.225, 0.25], [0.25, 0.225, -0.25], [-0.25, 0.225, -0.25]];
        positions.forEach(p => {
            const l = new THREE.Mesh(legGeo, chairMat);
            l.position.set(...p);
            l.castShadow = true;
            l.receiveShadow = true;
            g.add(l);
        });
        return g;
    }

    const rows = 6;
    const baseRadius = 10;
    const spacing = 3.5;
    const chairProto = createChair();
    const chairGroup = new THREE.Group();
    
    for(let r=0; r<rows; r++) {
        const radius = baseRadius + (r * spacing);
        const count = Math.floor((2 * Math.PI * radius) / 2.5); 
        
        for(let i=0; i<count; i++) {
            const angle = (i/count) * Math.PI * 2;
            if(Math.abs(angle - Math.PI/2) < 0.3 || Math.abs(angle - 3*Math.PI/2) < 0.3) continue;

            const c = chairProto.clone();
            c.position.set(Math.cos(angle) * radius, 0, Math.sin(angle) * radius);
            c.lookAt(0, 1, 0); 
            c.scale.setScalar(1.5); 
            chairGroup.add(c);
        }
    }
    scene.add(chairGroup);

    const clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      const dt = clock.getDelta();
      if (mixer) mixer.update(dt);
      beltTex.offset.y -= dt * 1.5; 
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
