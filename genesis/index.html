<!-- 
    HEARTBREAK PRESET — SHOWCASE #5: GENESIS (THE FINALE)
    
    Concept: The Big Bang. Void -> Singularity -> Explosion -> World Creation.
    Authored by: Flux ⚡
    Date: 2026-02-26
    
    TECHNICAL STACK:
    - Three.js r160+ (CDN)
    - Custom GLSL Particle System (Explosion mechanics)
    - Volumetric Nebula Shader
    - Procedural Audio (Web Audio API)
    - GSAP Sequencing (The Choreographer)
    - Post-Processing: Bloom, Film Grain, Chromatic Aberration
-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HBI Showcase #5: GENESIS</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background-color: #000000;
            overflow: hidden;
            font-family: 'Helvetica Neue', Arial, sans-serif;
            color: white;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0; left: 0; z-index: 1;
        }
        #ui-layer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 10;
            pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between; padding: 2rem;
            mix-blend-mode: difference;
        }
        .header, .footer {
            text-transform: uppercase; letter-spacing: 0.15em; font-size: 0.8rem; font-weight: 700;
            display: flex; justify-content: space-between;
        }
        .title-block h1 {
            font-size: 4rem; line-height: 0.9; font-weight: 800; letter-spacing: -0.02em; margin: 0;
            opacity: 0; /* Hidden initially */
        }
        #start-btn {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            z-index: 20; pointer-events: auto; cursor: pointer;
            background: transparent; border: 1px solid rgba(255,255,255,0.3);
            color: white; padding: 1rem 2rem; font-size: 0.8rem; letter-spacing: 0.2em; text-transform: uppercase;
            transition: all 0.3s ease;
        }
        #start-btn:hover { background: white; color: black; }
    </style>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
            "gsap": "https://unpkg.com/gsap@3.12.5/index.js"
        }
    }
    </script>
</head>
<body><a href="../" style="position:fixed;top:16px;left:16px;z-index:9999;color:#4488ff;font-family:monospace;font-size:0.8rem;text-decoration:none;opacity:0.6;letter-spacing:0.1em;padding:6px 12px;border:1px solid rgba(68,136,255,0.3);border-radius:4px;background:rgba(10,10,18,0.8);transition:opacity 0.3s" onmouseover="this.style.opacity=1" onmouseout="this.style.opacity=0.6">← GALLERY</a>

    <button id="start-btn">INITIATE GENESIS</button>

    <div id="ui-layer">
        <div class="header">
            <span>Heartbreak Ink</span>
            <span>Showcase 05/05</span>
        </div>
        <div class="footer">
            <div class="title-block">
                <h1 id="title-text">GENESIS</h1>
            </div>
            <div class="status">
                FLUX CORE<br>
                Sequence: FINALE
            </div>
        </div>
    </div>

    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
        import gsap from 'gsap';

        // ------------------------------------------------------------------
        // CONFIG & STATE
        // ------------------------------------------------------------------
        const CONFIG = {
            bloom: { strength: 0.0, radius: 0.5, threshold: 0.1 }, // Starts at 0
            camera: { startZ: 2, endZ: 35 },
            colors: {
                core: new THREE.Color(0xffffff),
                nebula1: new THREE.Color(0x00ffff), // Cyan
                nebula2: new THREE.Color(0xff0055), // Magenta
                nebula3: new THREE.Color(0x4400ff), // Deep Purple
            }
        };

        const STATE = {
            exploded: false,
            time: 0,
            expansionSpeed: 0
        };

        // ------------------------------------------------------------------
        // SHADER CHUNK LIBRARY
        // ------------------------------------------------------------------
        
        // 1. Particle Explosion Shader
        const particleVertexShader = `
            uniform float time;
            uniform float expansion;
            attribute float size;
            attribute vec3 velocity;
            attribute vec3 color;
            attribute float spawnTime;
            
            varying vec3 vColor;
            varying float vAlpha;

            void main() {
                vColor = color;
                
                // Physics: Expand from center based on velocity and expansion factor
                vec3 pos = position + velocity * expansion * (time * 2.0);
                
                // Spiral twist effect
                float angle = length(pos) * 0.2;
                float s = sin(angle);
                float c = cos(angle);
                mat2 rot = mat2(c, -s, s, c);
                pos.xz = rot * pos.xz;

                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                
                // Size attenuation
                gl_PointSize = size * (200.0 / -mvPosition.z);
                
                gl_Position = projectionMatrix * mvPosition;
                
                // Fade out based on life
                vAlpha = 1.0 - smoothstep(5.0, 15.0, length(pos));
            }
        `;

        const particleFragmentShader = `
            varying vec3 vColor;
            varying float vAlpha;
            
            void main() {
                // Circular particle
                vec2 center = gl_PointCoord - 0.5;
                float dist = length(center);
                if (dist > 0.5) discard;
                
                // Soft edge
                float alpha = (0.5 - dist) * 2.0 * vAlpha;
                
                gl_FragColor = vec4(vColor, alpha);
            }
        `;

        // 2. Nebula Cloud Shader (Volumetric feel)
        const nebulaVertexShader = `
            varying vec2 vUv;
            varying vec3 vPos;
            void main() {
                vUv = uv;
                vPos = position;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const nebulaFragmentShader = `
            uniform float time;
            uniform vec3 color1;
            uniform vec3 color2;
            uniform float opacity;
            varying vec2 vUv;
            varying vec3 vPos;

            // Simplex Noise (Approximation)
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

            float snoise(vec3 v) {
                const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                vec3 i  = floor(v + dot(v, C.yyy));
                vec3 x0 = v - i + dot(i, C.xxx);
                vec3 g = step(x0.yzx, x0.xyz);
                vec3 l = 1.0 - g;
                vec3 i1 = min( g.xyz, l.zxy );
                vec3 i2 = max( g.xyz, l.zxy );
                vec3 x1 = x0 - i1 + C.xxx;
                vec3 x2 = x0 - i2 + C.yyy;
                vec3 x3 = x0 - D.yyy;
                i = mod289(i);
                vec4 p = permute( permute( permute( i.z + vec4(0.0, i1.z, i2.z, 1.0 )) + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
                float n_ = 0.142857142857;
                vec3  ns = n_ * D.wyz - D.xzx;
                vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                vec4 x_ = floor(j * ns.z);
                vec4 y_ = floor(j - 7.0 * x_ );
                vec4 x = x_ *ns.x + ns.yyyy;
                vec4 y = y_ *ns.x + ns.yyyy;
                vec4 h = 1.0 - abs(x) - abs(y);
                vec4 b0 = vec4( x.xy, y.xy );
                vec4 b1 = vec4( x.zw, y.zw );
                vec4 s0 = floor(b0)*2.0 + 1.0;
                vec4 s1 = floor(b1)*2.0 + 1.0;
                vec4 sh = -step(h, vec4(0.0));
                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
                vec3 p0 = vec3(a0.xy,h.x);
                vec3 p1 = vec3(a0.zw,h.y);
                vec3 p2 = vec3(a1.xy,h.z);
                vec3 p3 = vec3(a1.zw,h.w);
                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
                p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                m = m * m;
                return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
            }

            void main() {
                // Noise field
                float n = snoise(vPos * 0.5 + time * 0.2);
                float n2 = snoise(vPos * 1.0 - time * 0.1);
                
                float combined = (n + n2) * 0.5;
                
                // Color mixing
                vec3 color = mix(color1, color2, combined + 0.5);
                
                // Transparency edges
                float alpha = smoothstep(0.0, 0.5, combined) * opacity;
                
                gl_FragColor = vec4(color, alpha);
            }
        `;

        // 3. Heartbreak Post-Process Shader (V1 Standard)
        const heartbreakShader = {
            uniforms: {
                "tDiffuse": { value: null },
                "time": { value: 0.0 },
                "amount": { value: 0.002 }, // CA
                "grainOpacity": { value: 0.05 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform float time;
                uniform float amount;
                uniform float grainOpacity;
                varying vec2 vUv;

                float random(vec2 p) {
                    return fract(cos(dot(p, vec2(23.14069263277926, 2.665144142690225))) * 12345.6789);
                }

                void main() {
                    // CA
                    float r = texture2D(tDiffuse, vUv + vec2(amount, 0.0)).r;
                    float g = texture2D(tDiffuse, vUv).g;
                    float b = texture2D(tDiffuse, vUv - vec2(amount, 0.0)).b;
                    vec3 color = vec3(r, g, b);

                    // Grain
                    vec2 uvRandom = vUv;
                    uvRandom.y *= random(vec2(uvRandom.y, time));
                    color += (random(uvRandom) - 0.5) * grainOpacity;

                    // Vignette
                    float dist = distance(vUv, vec2(0.5));
                    color *= smoothstep(0.8, 0.2, dist * 0.9);

                    gl_FragColor = vec4(color, 1.0);
                }
            `
        };

        // ------------------------------------------------------------------
        // MAIN SETUP
        // ------------------------------------------------------------------
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, CONFIG.camera.startZ);

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.enableZoom = false; // Controlled by script
        controls.enablePan = false;

        // ------------------------------------------------------------------
        // SCENE OBJECTS
        // ------------------------------------------------------------------
        
        // 1. THE SINGULARITY (The Seed)
        const singularityGeo = new THREE.SphereGeometry(0.05, 32, 32);
        const singularityMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const singularity = new THREE.Mesh(singularityGeo, singularityMat);
        scene.add(singularity);

        // 2. PARTICLE SYSTEM (The Big Bang)
        const particleCount = 15000;
        const particleGeo = new THREE.BufferGeometry();
        const pPos = new Float32Array(particleCount * 3);
        const pVel = new Float32Array(particleCount * 3);
        const pSize = new Float32Array(particleCount);
        const pColor = new Float32Array(particleCount * 3);

        const colorPalette = [CONFIG.colors.nebula1, CONFIG.colors.nebula2, CONFIG.colors.nebula3, new THREE.Color(0xffffff)];

        for (let i = 0; i < particleCount; i++) {
            // Start at center
            pPos[i*3] = 0; pPos[i*3+1] = 0; pPos[i*3+2] = 0;
            
            // Random direction in sphere
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            const speed = 0.5 + Math.random() * 4.0;
            
            pVel[i*3] = Math.sin(phi) * Math.cos(theta) * speed;
            pVel[i*3+1] = Math.sin(phi) * Math.sin(theta) * speed;
            pVel[i*3+2] = Math.cos(phi) * speed;
            
            pSize[i] = Math.random() * 0.5;
            
            // Color pick
            const c = colorPalette[Math.floor(Math.random() * colorPalette.length)];
            pColor[i*3] = c.r;
            pColor[i*3+1] = c.g;
            pColor[i*3+2] = c.b;
        }

        particleGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
        particleGeo.setAttribute('velocity', new THREE.BufferAttribute(pVel, 3));
        particleGeo.setAttribute('size', new THREE.BufferAttribute(pSize, 1));
        particleGeo.setAttribute('color', new THREE.BufferAttribute(pColor, 3));

        const particleMat = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                expansion: { value: 0 }
            },
            vertexShader: particleVertexShader,
            fragmentShader: particleFragmentShader,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        const particleSystem = new THREE.Points(particleGeo, particleMat);
        particleSystem.frustumCulled = false; // Ensure visibility during explosion
        scene.add(particleSystem);

        // 3. GEOMETRY CLUSTERS (The Matter)
        const geometryGroup = new THREE.Group();
        scene.add(geometryGroup);
        
        const shapes = [];
        const geoMat = new THREE.MeshPhysicalMaterial({
            color: 0x222222,
            metalness: 0.9,
            roughness: 0.1,
            wireframe: true,
            emissive: 0x000000,
            emissiveIntensity: 0
        });

        // Generate debris
        for(let i=0; i<50; i++) {
            const type = Math.random();
            let geo;
            if(type < 0.33) geo = new THREE.TetrahedronGeometry(Math.random()*0.5);
            else if(type < 0.66) geo = new THREE.OctahedronGeometry(Math.random()*0.5);
            else geo = new THREE.IcosahedronGeometry(Math.random()*0.5);

            const mesh = new THREE.Mesh(geo, geoMat.clone());
            // Random position shell
            const dist = 5 + Math.random() * 10;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            
            mesh.userData = {
                targetPos: new THREE.Vector3(
                    Math.sin(phi) * Math.cos(theta) * dist,
                    Math.sin(phi) * Math.sin(theta) * dist,
                    Math.cos(phi) * dist
                ),
                rotSpeed: new THREE.Vector3(Math.random()*0.02, Math.random()*0.02, Math.random()*0.02)
            };
            
            mesh.position.set(0,0,0); // Start at center
            mesh.scale.set(0,0,0); // Start invisible
            
            shapes.push(mesh);
            geometryGroup.add(mesh);
        }

        // 4. NEBULA (The Atmosphere)
        const nebulaGeo = new THREE.SphereGeometry(20, 64, 64);
        const nebulaMat = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                color1: { value: CONFIG.colors.nebula1 },
                color2: { value: CONFIG.colors.nebula3 },
                opacity: { value: 0.0 }
            },
            vertexShader: nebulaVertexShader,
            fragmentShader: nebulaFragmentShader,
            transparent: true,
            side: THREE.BackSide, // Inside the sphere
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });
        const nebula = new THREE.Mesh(nebulaGeo, nebulaMat);
        scene.add(nebula);

        // 5. LIGHTS
        const ambient = new THREE.AmbientLight(0x000000); // Start black
        scene.add(ambient);

        const pointLight = new THREE.PointLight(0xffffff, 0, 100);
        pointLight.position.set(0,0,0);
        scene.add(pointLight);

        // ------------------------------------------------------------------
        // POST PROCESSING
        // ------------------------------------------------------------------
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0, 0.5, 0);
        composer.addPass(bloomPass);
        
        const hbiPass = new ShaderPass(heartbreakShader);
        composer.addPass(hbiPass);
        composer.addPass(new OutputPass());

        // ------------------------------------------------------------------
        // AUDIO SYSTEM (Web Audio API)
        // ------------------------------------------------------------------
        let audioCtx;
        let oscillators = [];
        let gainNodes = [];

        function initAudio() {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            
            // 1. Deep Drone (The Universe Hum)
            const osc1 = audioCtx.createOscillator();
            const gain1 = audioCtx.createGain();
            osc1.type = 'sine';
            osc1.frequency.value = 55; // A1
            gain1.gain.value = 0;
            osc1.connect(gain1);
            gain1.connect(audioCtx.destination);
            osc1.start();
            oscillators.push(osc1);
            gainNodes.push(gain1);

            // 2. High Shimmer (The Light)
            const osc2 = audioCtx.createOscillator();
            const gain2 = audioCtx.createGain();
            osc2.type = 'triangle';
            osc2.frequency.value = 440; // A4
            gain2.gain.value = 0;
            osc2.connect(gain2);
            gain2.connect(audioCtx.destination);
            osc2.start();
            oscillators.push(osc2);
            gainNodes.push(gain2);

            return { gain1, gain2, osc1, osc2 };
        }

        // ------------------------------------------------------------------
        // SEQUENCER (THE GENESIS)
        // ------------------------------------------------------------------
        function startGenesis() {
            document.getElementById('start-btn').style.opacity = 0;
            document.getElementById('start-btn').style.pointerEvents = 'none';

            const audio = initAudio();
            const tl = gsap.timeline();

            // STEP 1: The Pulse (0s - 4s)
            // Pulse the singularity, bring in high tone
            tl.to(singularity.scale, { x: 2, y: 2, z: 2, duration: 1, ease: "power2.inOut", repeat: 1, yoyo: true });
            tl.to(audio.gain2.gain, { value: 0.1, duration: 2 }, "<");
            
            tl.to(singularity.scale, { x: 0.1, y: 0.1, z: 0.1, duration: 0.5, ease: "power4.in" }); // Compress
            tl.to(audio.osc2.frequency, { value: 880, duration: 0.5 }, "<"); // Pitch up
            
            // STEP 2: THE EXPLOSION (4.5s)
            tl.call(() => {
                STATE.exploded = true;
                scene.remove(singularity); // Gone
                
                // Audio Blast
                audio.gain1.gain.linearRampToValueAtTime(0.8, audioCtx.currentTime + 0.1); // Bass kick
                audio.gain1.gain.exponentialRampToValueAtTime(0.3, audioCtx.currentTime + 2.0); // Sustain
                
                audio.gain2.gain.setValueAtTime(0.5, audioCtx.currentTime);
                audio.gain2.gain.exponentialRampToValueAtTime(0.0, audioCtx.currentTime + 1.0); // Ping fade
            });

            // Visual Explosion
            tl.to(particleMat.uniforms.expansion, { value: 1, duration: 10, ease: "power1.out" }, "<");
            tl.to(bloomPass, { strength: 3.0, radius: 1.0, duration: 0.2, yoyo: true, repeat: 1 }, "<"); // Flash
            tl.to(bloomPass, { strength: 1.5, duration: 5 }, ">"); // Settle bloom
            
            // Camera Pullback
            tl.to(camera.position, { z: CONFIG.camera.endZ, duration: 8, ease: "power2.out" }, "<");
            
            // Reveal Nebula
            tl.to(nebulaMat.uniforms.opacity, { value: 0.6, duration: 6 }, "<+=1");
            
            // Reveal Geometry
            shapes.forEach((mesh, i) => {
                // Staggered appearance
                tl.to(mesh.position, { 
                    x: mesh.userData.targetPos.x,
                    y: mesh.userData.targetPos.y,
                    z: mesh.userData.targetPos.z,
                    duration: 4 + Math.random() * 2,
                    ease: "power2.out"
                }, "<");
                tl.to(mesh.scale, { x: 1, y: 1, z: 1, duration: 1 }, "<+=" + (i * 0.05));
                tl.to(mesh.material.emissive, { r:1, g:1, b:1, duration: 0.5 }, "<");
                tl.to(mesh.material, { emissiveIntensity: 2, duration: 0.2, yoyo: true, repeat: 1 }, "<");
            });

            // Light up world
            tl.to(ambient, { intensity: 0.2, duration: 5 }, "<");
            tl.to(pointLight, { intensity: 2, duration: 2 }, "<");

            // UI Reveal
            tl.to('#title-text', { opacity: 1, duration: 3, ease: "power2.out" }, "-=2");
        }

        document.getElementById('start-btn').addEventListener('click', startGenesis);

        // ------------------------------------------------------------------
        // ANIMATION LOOP
        // ------------------------------------------------------------------
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            
            const time = clock.getElapsedTime();
            
            // Update Uniforms
            particleMat.uniforms.time.value = time;
            nebulaMat.uniforms.time.value = time;
            hbiPass.uniforms.time.value = time;

            // Rotate Nebula slowly
            nebula.rotation.y = time * 0.05;
            nebula.rotation.z = time * 0.02;

            // Geometry Cluster movement
            if (STATE.exploded) {
                geometryGroup.rotation.y += 0.002;
                shapes.forEach(mesh => {
                    mesh.rotation.x += mesh.userData.rotSpeed.x;
                    mesh.rotation.y += mesh.userData.rotSpeed.y;
                });
            }

            controls.update();
            composer.render();
        }

        animate();
        
        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
