<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Ferrari Commercial G2 - Premium Lookdev</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; }
        canvas { display: block; }
        #info { 
            position: absolute; top: 20px; width: 100%; text-align: center; 
            color: #888; font-family: 'Helvetica Neue', Arial, sans-serif; 
            pointer-events: none; font-size: 12px; letter-spacing: 2px; text-transform: uppercase;
        }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #444; font-family: sans-serif; font-size: 14px;
        }
    </style>
</head>
<body>
    <div id="info">Ferrari Commercial G2: Premium Lookdev | 4K Anamorphic</div>
    <div id="loading">Loading Assets...</div>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';

        // --- Config ---
        const ASSETS = {
            horse: '../assets/hero_horse.glb', // Relative path from g2/ to assets/
            // Fallback to CDN if local fails (handled in loader error)
            horseUrl: 'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/models/gltf/Horse.glb'
        };

        // --- Scene Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x080808); // Deep void, lifted slightly for readability
        scene.fog = new THREE.FogExp2(0x080808, 0.014); // Lighter fog so subject stays visible

        // --- Camera (Cinema) ---
        const camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(4, 2, 6); // Hero angle: Front-quarter low
        camera.lookAt(0, 1.2, 0);

        // --- Renderer ---
        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.35;
        document.body.appendChild(renderer.domElement);

        // --- Controls ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 3;
        controls.maxDistance = 15;
        controls.target.set(0, 1, 0);

        // --- Lighting (Chiaroscuro) ---

        // 1. Key Light (Top-down spotlight)
        const spotLight = new THREE.SpotLight(0xffffff, 4200); 
        spotLight.position.set(0, 14, 0);
        spotLight.angle = Math.PI / 10;
        spotLight.penumbra = 0.6;
        spotLight.decay = 2;
        spotLight.distance = 28;
        spotLight.castShadow = true;
        spotLight.shadow.mapSize.width = 2048;
        spotLight.shadow.mapSize.height = 2048;
        spotLight.shadow.bias = -0.0001;
        spotLight.target.position.set(0, 0.9, 0);
        scene.add(spotLight.target);
        scene.add(spotLight);

        // 2. Rim Light (Cold)
        const rimLight = new THREE.SpotLight(0xaaccff, 1100);
        rimLight.position.set(0, 3, -6);
        rimLight.lookAt(0, 1.5, 0);
        rimLight.angle = Math.PI / 4;
        rimLight.penumbra = 1;
        scene.add(rimLight);

        // 3. Fill (Very dark)
        const ambient = new THREE.AmbientLight(0x2a2a2a, 1.0); 
        scene.add(ambient);

        // 4. Overhead fill to keep horse readable while preserving contrast
        const hemi = new THREE.HemisphereLight(0xffffff, 0x0a0a0a, 0.6);
        scene.add(hemi);

        // --- Materials ---

        const floorMat = new THREE.MeshStandardMaterial({
            color: 0x050505,
            roughness: 0.1,
            metalness: 0.8, // Black glass / polished concrete
        });

        const treadmillMat = new THREE.MeshStandardMaterial({
            color: 0x111111,
            roughness: 0.3,
            metalness: 0.5,
        });

        // "Sweaty Horse" Material
        const horseMat = new THREE.MeshStandardMaterial({
            color: 0xf8f8f6, // Bright white coat
            emissive: 0x111111, // Prevent crushed blacks on the horse body
            emissiveIntensity: 0.35,
            roughness: 0.26,
            metalness: 0.0,
            clearcoat: 1.0,
            clearcoatRoughness: 0.14
        });

        // --- Objects ---

        // 1. Floor (Infinite Void Reflection)
        const floorGeo = new THREE.PlaneGeometry(50, 50);
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // 2. Treadmill
        const treadmillGroup = new THREE.Group();
        const baseGeo = new THREE.BoxGeometry(1.2, 0.15, 3.5);
        const base = new THREE.Mesh(baseGeo, treadmillMat);
        base.position.y = 0.075;
        base.receiveShadow = true;
        treadmillGroup.add(base);
        
        // Moving Belt (Illusion via texture offset)
        const beltGeo = new THREE.PlaneGeometry(1, 3.2);
        const beltTex = new THREE.TextureLoader().load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/uv_grid_opengl.jpg');
        beltTex.wrapS = THREE.RepeatWrapping;
        beltTex.wrapT = THREE.RepeatWrapping;
        beltTex.repeat.set(1, 4);
        const beltMat = new THREE.MeshStandardMaterial({ 
            map: beltTex, 
            color: 0x222222,
            roughness: 0.8 
        });
        const belt = new THREE.Mesh(beltGeo, beltMat);
        belt.rotation.x = -Math.PI / 2;
        belt.position.y = 0.16; // Just above base
        belt.receiveShadow = true;
        treadmillGroup.add(belt);

        scene.add(treadmillGroup);

        // 3. Chairs (Abstract/Silhouettes)
        const chairGeo = new THREE.BoxGeometry(0.4, 0.8, 0.4);
        const chairMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.9 });
        const chairCount = 400;
        const chairs = new THREE.InstancedMesh(chairGeo, chairMat, chairCount);
        const dummy = new THREE.Object3D();
        let idx = 0;
        
        // Auditorium Layout
        for (let r = 6; r < 20; r += 1.5) {
            const count = Math.floor(2 * Math.PI * r / 0.8);
            for (let i = 0; i < count; i++) {
                if (idx >= chairCount) break;
                const angle = (i / count) * Math.PI * 2 + Math.PI; // Start from back
                // Gap in front for camera
                if (angle > Math.PI * 0.8 && angle < Math.PI * 1.2) {
                   // Keep clear
                } else {
                    dummy.position.set(
                        Math.cos(angle) * r,
                        0.4 + (r - 6) * 0.2, // Tiered seating rise
                        Math.sin(angle) * r
                    );
                    dummy.lookAt(0, 1, 0);
                    dummy.updateMatrix();
                    chairs.setMatrixAt(idx++, dummy.matrix);
                }
            }
        }
        chairs.receiveShadow = true;
        scene.add(chairs);

        // 4. The Horse (Animated)
        let mixer;
        const loader = new GLTFLoader();
        
        // Try loading local asset first, fallback to URL
        // In browser context, relative path might fail due to CORS if run locally without server,
        // but this artifact is designed to be served. 
        // We will try the online URL for robustness in this preview artifact.
        
        loader.load( ASSETS.horseUrl, function ( gltf ) {

            const model = gltf.scene;
            model.traverse( function ( object ) {
                if ( object.isMesh ) {
                    object.castShadow = true;
                    object.receiveShadow = true;
                    // Force premium white coat material
                    object.material = horseMat.clone();
                    if (object.material.map) object.material.map = null;
                    object.material.needsUpdate = true;
                }
            } );
            
            // Adjust Scale & Position to fit treadmill
            model.scale.set( 0.015, 0.015, 0.015 ); // The example horse is huge or tiny, let's guess
            // Actually the three.js horse example is usually unit scale approx.
            // Let's re-check standard scale. It's usually small.
            model.scale.set( 0.008, 0.008, 0.008 ); 
            model.position.set( 0, 0.16, 0 ); 
            model.rotation.y = Math.PI; // Face forward

            scene.add( model );

            mixer = new THREE.AnimationMixer( model );
            const action = mixer.clipAction( gltf.animations[ 0 ] );
            action.timeScale = 1.5; // Run faster
            action.play();
            
            document.getElementById('loading').style.display = 'none';

        }, undefined, function ( error ) {
            console.error( error );
            document.getElementById('loading').innerText = 'Error loading model';
        } );

        // --- Loop ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame( animate );
            
            const delta = clock.getDelta();
            if ( mixer ) mixer.update( delta );

            // Animate Belt (aligned with horse stride direction)
            beltTex.offset.y += delta * 1.5; // Reversed per feedback
            
            controls.update();
            renderer.render( scene, camera );
        }

        animate();

        // --- Resize ---
        window.addEventListener( 'resize', onWindowResize, false );
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize( window.innerWidth, window.innerHeight );
        }
    </script>
</body>
</html>
