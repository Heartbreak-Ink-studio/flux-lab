<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Ferrari Commercial G2.5 v5 (Forge Fix)</title>
  <style>
    body { margin: 0; overflow: hidden; background: #050505; }
    #info { position: fixed; top: 12px; width: 100%; text-align: center; color: #888; font: 11px/1.2 "Helvetica Neue", Arial, sans-serif; letter-spacing: 3px; text-transform: uppercase; pointer-events: none; opacity: 0.7; }
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div id="info">Ferrari Commercial G2.5 v5 â€” Grand Hall Ceremony (Forge Fix)</div>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { RectAreaLightHelper } from 'three/addons/helpers/RectAreaLightHelper.js';
    import { RectAreaLightUniformsLib } from 'three/addons/lights/RectAreaLightUniformsLib.js';

    // -- TEXTURE GENERATION (Procedural Detail) --
    function createNoiseTexture() {
      const size = 512;
      const canvas = document.createElement('canvas');
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext('2d');
      
      // FIX: Use standard normal map base color (128, 128, 255)
      // Gray (128,128,128) creates zero-length normals!
      ctx.fillStyle = '#8080ff'; 
      ctx.fillRect(0, 0, size, size);
      
      const id = ctx.getImageData(0,0,size,size);
      const d = id.data;
      for(let i=0; i<d.length; i+=4){
        // Add subtle noise to R and G channels (X and Y normals)
        const val = (Math.random() * 60 - 30);
        d[i] = Math.min(255, Math.max(0, d[i] + val));     // Red (X)
        d[i+1] = Math.min(255, Math.max(0, d[i+1] + val)); // Green (Y)
        // Keep Blue (Z) strong for surface normal direction
        d[i+2] = Math.min(255, Math.max(200, d[i+2] + (val * 0.1))); 
      }
      ctx.putImageData(id, 0, 0);
      const tex = new THREE.CanvasTexture(canvas);
      tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
      // Normal maps should be Linear encoding (NoColorSpace in new Three.js)
      tex.colorSpace = THREE.NoColorSpace; 
      return tex;
    }

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x050505);
    scene.fog = new THREE.FogExp2(0x050505, 0.015);

    const camera = new THREE.PerspectiveCamera(35, innerWidth / innerHeight, 0.1, 300);
    camera.position.set(5.5, 3.2, 8.5); // Slightly pulled back for grandeur
    camera.lookAt(0, 1.2, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, stencil: false });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.1;
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.maxPolarAngle = Math.PI / 2 - 0.05; // Prevent going below floor
    controls.target.set(0, 1.2, 0);

    // -- LIGHTING (Cinematic Ceremony) --
    // Hero Spot
    const spot = new THREE.SpotLight(0xffffff, 5200, 70, Math.PI / 9, 0.6, 1.6);
    spot.position.set(0, 26, 0);
    spot.target.position.set(0, 0, 0);
    spot.castShadow = true;
    spot.shadow.mapSize.set(2048, 2048);
    spot.shadow.bias = -0.0001;
    scene.add(spot);
    scene.add(spot.target);

    // Ambient Fill (Cool Hall)
    const hemi = new THREE.HemisphereLight(0xf5f7ff, 0x15151a, 0.85);
    scene.add(hemi);

    // Rim/Backlight for definition
    const rim = new THREE.SpotLight(0xcceeff, 2300, 55, Math.PI / 6, 0.85, 1);
    rim.position.set(-8, 10, -10);
    rim.lookAt(0, 0, 0);
    scene.add(rim);

    // Dedicated horse fill light to guarantee white read
    const horseFill = new THREE.PointLight(0xffffff, 380, 22);
    horseFill.position.set(1.5, 3.0, 3.5);
    scene.add(horseFill);

    // -- ARCHITECTURE (Grand Hall) --
    const matStone = new THREE.MeshStandardMaterial({ 
      color: 0x1a1a1a, 
      roughness: 0.7,
      metalness: 0.2
    });
    
    // We can reuse the noise texture for roughness variation on the floor too,
    // but typically normal maps shouldn't be used directly as roughness maps without care.
    // For simplicity, we'll keep the floor map generation separate or just reuse the existing function logic if needed.
    // However, the original code reused the SAME createNoiseTexture() for floor map?
    // Wait, the original code reused createNoiseTexture() for matFloor.map (Albedo/Diffuse).
    // If used as Albedo, #8080ff will make the floor blue!
    // FIX: We need TWO texture generators. One for Albedo (Gray), One for Normal (Blue).

    function createGrayNoiseTexture() {
      const size = 512;
      const canvas = document.createElement('canvas');
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = '#111111'; // Dark floor base
      ctx.fillRect(0, 0, size, size);
      
      const id = ctx.getImageData(0,0,size,size);
      const d = id.data;
      for(let i=0; i<d.length; i+=4){
        const val = (Math.random() * 30 - 15);
        d[i] = Math.min(255, Math.max(0, d[i] + val));
        d[i+1] = Math.min(255, Math.max(0, d[i+1] + val));
        d[i+2] = Math.min(255, Math.max(0, d[i+2] + val));
      }
      ctx.putImageData(id, 0, 0);
      const tex = new THREE.CanvasTexture(canvas);
      tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
      tex.colorSpace = THREE.SRGBColorSpace;
      return tex;
    }

    const matFloor = new THREE.MeshStandardMaterial({
      color: 0x111111,
      roughness: 0.15, // Polished
      metalness: 0.6,
      map: createGrayNoiseTexture() // Use dedicated Albedo generator
    });
    matFloor.map.repeat.set(20,20);
    matFloor.map.anisotropy = 16;
    
    // Floor
    const floor = new THREE.Mesh(new THREE.PlaneGeometry(150, 150), matFloor);
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);

    // Columns
    const colGeo = new THREE.CylinderGeometry(1.2, 1.2, 35, 32);
    const colCount = 12;
    const colRadius = 25;
    for(let i=0; i<colCount; i++) {
        const a = (i/colCount) * Math.PI * 2;
        const c = new THREE.Mesh(colGeo, matStone);
        c.position.set(Math.cos(a)*colRadius, 17.5, Math.sin(a)*colRadius);
        c.castShadow = true;
        c.receiveShadow = true;
        scene.add(c);
    }

    // Ceiling Beams (creating shadows/depth overhead)
    const beamGeo = new THREE.BoxGeometry(60, 2, 2);
    for(let k=0; k<4; k++) {
        const b = new THREE.Mesh(beamGeo, matStone);
        b.position.y = 28;
        b.rotation.y = (k/4) * Math.PI;
        b.castShadow = true;
        scene.add(b);
    }
    
    // -- TREADMILL (Preserved) --
    const treadmill = new THREE.Group();
    const tBase = new THREE.Mesh(
      new THREE.BoxGeometry(1.6, 0.2, 5.0), 
      new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.3, metalness: 0.8 })
    );
    tBase.position.y = 0.1;
    tBase.receiveShadow = true;
    treadmill.add(tBase);
    
    const beltTex = new THREE.TextureLoader().load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/uv_grid_opengl.jpg');
    beltTex.wrapS = beltTex.wrapT = THREE.RepeatWrapping;
    beltTex.repeat.set(1, 8);
    const tBelt = new THREE.Mesh(
        new THREE.PlaneGeometry(1.3, 4.6),
        new THREE.MeshStandardMaterial({ map: beltTex, color: 0x111111, roughness: 0.9 })
    );
    tBelt.rotation.x = -Math.PI/2;
    tBelt.position.y = 0.21;
    treadmill.add(tBelt);
    scene.add(treadmill);

    // -- ASSETS --
    const loader = new GLTFLoader();
    
    // Shared Noise for Horse Detail (Normal Map)
    const skinDetailMap = createNoiseTexture(); // Uses the Blue base
    skinDetailMap.repeat.set(30, 30); // Fine grain

    let mixer = null;
    
    // Horse (High Fidelity White)
    loader.load('assets/hero_horse.glb', (gltf) => {
      const horse = gltf.scene;
      
      const whiteHorseMat = new THREE.MeshPhysicalMaterial({
        color: 0xffffff,
        emissive: 0x5a5a5a,
        emissiveIntensity: 0.75,
        roughness: 0.34,
        metalness: 0.0,

        // Corrected Normal Map
        normalMap: skinDetailMap,
        normalScale: new THREE.Vector2(0.06, 0.06),

        sheen: 1.0,
        sheenColor: 0xffffff,
        sheenRoughness: 0.45,
        clearcoat: 0.5,
        clearcoatRoughness: 0.2,

        side: THREE.DoubleSide
      });

      horse.traverse((o) => {
        if (o.isMesh) {
          o.castShadow = true;
          o.receiveShadow = true;
          o.material = whiteHorseMat;
        }
      });
      
      const s = 0.012; // Scale preserved
      horse.scale.set(s, s, s);
      horse.rotation.y = Math.PI; // Running away/forward relative to cam
      horse.position.y = 0.21; // On belt
      
      scene.add(horse);
      
      mixer = new THREE.AnimationMixer(horse);
      const action = mixer.clipAction(gltf.animations[0]);
      action.timeScale = 1.8;
      action.play();
    });

    // Premium Chairs (Preserved layout, tuned material)
    loader.load('assets/premium_chair/modern_arm_chair_01_1k.gltf', (gltf) => {
        const chair = gltf.scene;
        
        chair.traverse(c => {
            if(c.isMesh) {
                c.castShadow = true;
                c.receiveShadow = true;
                if(c.material) {
                   c.material.color.multiplyScalar(0.8); 
                   c.material.roughness = 0.5;
                }
            }
        });

        // Auditorium Layout
        const rows = 6;
        const baseRadius = 10;
        const spacing = 3.5;
        
        for(let r=0; r<rows; r++) {
            const radius = baseRadius + (r * spacing);
            const circumference = 2 * Math.PI * radius;
            const count = Math.floor(circumference / 2.5); // Density
            
            for(let i=0; i<count; i++) {
                const angle = (i/count) * Math.PI * 2;
                if(Math.abs(angle - Math.PI/2) < 0.3 || Math.abs(angle - 3*Math.PI/2) < 0.3) continue;

                const cInst = chair.clone();
                cInst.position.set(
                    Math.cos(angle) * radius,
                    0,
                    Math.sin(angle) * radius
                );
                cInst.lookAt(0, 1, 0); 
                cInst.scale.setScalar(2.0); 
                
                scene.add(cInst);
            }
        }
    });

    // Animation Loop
    const clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      const dt = clock.getDelta();
      
      if (mixer) mixer.update(dt);
      
      // Belt animation
      beltTex.offset.y -= dt * 1.5; // Moving back

      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
