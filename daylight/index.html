<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>HEARTBREAK INK â€” DAYLIGHT v3</title>
  <style>
    html, body { margin:0; width:100%; height:100%; overflow:hidden; background:#0a0a12; }
    #app { width:100%; height:100%; }
    #watermark { position:fixed; right:16px; bottom:12px; color:rgba(255,255,255,.3); font:11px monospace; letter-spacing:.16em; z-index:30; pointer-events:none; }
    #titleCard { position:fixed; inset:0; display:flex; align-items:flex-end; justify-content:center; padding-bottom:14vh; color:#fff7df; font:700 28px/1.1 monospace; letter-spacing:.35em; opacity:0; transition:opacity 1.6s ease; text-shadow:0 0 28px rgba(255,180,100,.35); pointer-events:none; z-index:35; }
    #hint { position:fixed; left:50%; top:16px; transform:translateX(-50%); color:rgba(255,255,255,.75); font:12px monospace; letter-spacing:.08em; z-index:40; }
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div id="app"></div>
  <div id="hint">tap to enable cinematic audio</div>
  <div id="titleCard">HEARTBREAK INK</div>
  <div id="watermark">HEARTBREAK INK</div>

  <script type="module">
    import * as THREE from 'three';
    import { HBI_DEFAULTS } from '../lib/hbi-defaults.js';

    async function importFromCandidates(file) {
      const bases = ['../lib/', './lib/'];
      for (const base of bases) {
        try { return await import(base + file); } catch (_) {}
      }
      throw new Error(`Unable to import ${file} from lib paths`);
    }

    const [{ AssetLoader }, { CameraRail }, { AnimationManager }, { PostStack }] = await Promise.all([
      importFromCandidates('asset-loader.js'),
      importFromCandidates('camera-rail.js'),
      importFromCandidates('animation-manager.js'),
      importFromCandidates('post-stack.js')
    ]);

    const app = document.getElementById('app');
    const hint = document.getElementById('hint');
    const titleCard = document.getElementById('titleCard');

    const scene = new THREE.Scene();
    scene.background = new THREE.Color('#f2bd73');
    scene.fog = new THREE.Fog('#f0b774', 40, 240);

    const camera = new THREE.PerspectiveCamera(54, innerWidth / innerHeight, 0.1, 600);
    camera.position.set(-80, 12, 40);

    const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:'high-performance' });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 0.88;
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    app.appendChild(renderer.domElement);

    // HBI lights + sun-biased key for daylight warmth
    const key = new THREE.DirectionalLight('#ffd59a', 1.6);
    key.position.set(-48, 34, 14);
    key.castShadow = true;
    key.shadow.mapSize.set(HBI_DEFAULTS.lighting.shadowMapSize, HBI_DEFAULTS.lighting.shadowMapSize);
    key.shadow.camera.left = -120; key.shadow.camera.right = 120;
    key.shadow.camera.top = 90; key.shadow.camera.bottom = -90;
    key.shadow.camera.near = 1; key.shadow.camera.far = 320;
    key.shadow.bias = -0.0002;
    scene.add(key);

    const fill = new THREE.DirectionalLight(HBI_DEFAULTS.colors.key, 0.7);
    fill.position.set(32, 16, -16);
    scene.add(fill);

    const rim = new THREE.DirectionalLight(HBI_DEFAULTS.colors.rim, 1.1);
    rim.position.set(0, 14, -42);
    scene.add(rim);

    scene.add(new THREE.HemisphereLight('#ffe8c6', '#55706c', 0.35));
    scene.add(new THREE.AmbientLight('#ffdec1', 0.2));

    // Environment
    const roadLen = 360;
    const roadW = 14;
    const groups = { trees: [], birds: [], leaves: [], dust: [], sprinklers: [] };
    const rand = (a,b)=>THREE.MathUtils.randFloat(a,b);

    const ground = new THREE.Mesh(new THREE.PlaneGeometry(roadLen + 160, 170), new THREE.MeshStandardMaterial({ color:'#7ea766', roughness:.95 }));
    ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);

    const road = new THREE.Mesh(new THREE.PlaneGeometry(roadLen, roadW), new THREE.MeshStandardMaterial({ color:'#5d5a56', roughness:.92 }));
    road.rotation.x = -Math.PI/2; road.position.y = .03; road.receiveShadow = true; scene.add(road);

    const sidewalkMat = new THREE.MeshStandardMaterial({ color:'#b7b4ad', roughness:.96 });
    for (const side of [-1,1]) {
      const curb = new THREE.Mesh(new THREE.BoxGeometry(roadLen, .23, .34), new THREE.MeshStandardMaterial({ color:'#9f9a92', roughness:.95 }));
      curb.position.set(0, .12, side*(roadW/2 + .17)); curb.receiveShadow = curb.castShadow = true; scene.add(curb);
      const sideWalk = new THREE.Mesh(new THREE.PlaneGeometry(roadLen, 4.2), sidewalkMat);
      sideWalk.rotation.x = -Math.PI/2; sideWalk.position.set(0,.04,side*(roadW/2+2.3)); sideWalk.receiveShadow = true; scene.add(sideWalk);
    }

    // lane + crosswalk
    for (let i=0;i<40;i++) {
      const m = new THREE.Mesh(new THREE.BoxGeometry(4.2,.04,.22), new THREE.MeshStandardMaterial({ color:'#f7eac8', roughness:.65 }));
      m.position.set(-roadLen*.5 + 7 + i*9.1,.055,0); m.castShadow = true; scene.add(m);
    }
    for (let i=0;i<7;i++) {
      const c = new THREE.Mesh(new THREE.BoxGeometry(.8,.04,roadW-1), new THREE.MeshStandardMaterial({ color:'#f3f3f1', roughness:.72 }));
      c.position.set(-10 + i*1.25,.06,0); c.castShadow = true; scene.add(c);
    }

    function makeHouse(x,z,i){
      const w = rand(6,10), h = rand(4.5,7.2), d = rand(6,10);
      const color = new THREE.Color().setHSL(rand(0.06,0.16), rand(0.2,0.35), rand(0.72,0.84));
      const body = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), new THREE.MeshStandardMaterial({ color, roughness:.87 }));
      body.position.set(x,h*.5,z); body.castShadow = body.receiveShadow = true; scene.add(body);
      const roof = new THREE.Mesh(new THREE.ConeGeometry(Math.max(w,d)*.72, rand(1.5,2.5), 4), new THREE.MeshStandardMaterial({ color:'#6a5348', roughness:.9 }));
      roof.position.set(x,h+1.3,z); roof.rotation.y = (i%4)*Math.PI*0.125; roof.castShadow = true; scene.add(roof);
      const door = new THREE.Mesh(new THREE.BoxGeometry(.9,1.9,.08), new THREE.MeshStandardMaterial({ color:'#7c5237', roughness:.8 }));
      door.position.set(x+rand(-1.3,1.3), .95, z - Math.sign(z)*(d*.5+.04)); door.castShadow = true; scene.add(door);
    }

    function makeTree(x,z){
      const g = new THREE.Group();
      const trunkH = rand(2.2,3.7);
      const trunk = new THREE.Mesh(new THREE.CylinderGeometry(.18,.28,trunkH,9), new THREE.MeshStandardMaterial({ color:'#6a4a33', roughness:1 }));
      trunk.position.y = trunkH*.5; trunk.castShadow = trunk.receiveShadow = true; g.add(trunk);
      const leafMat = new THREE.MeshStandardMaterial({ color:new THREE.Color().setHSL(rand(.22,.30), rand(.35,.55), rand(.35,.5)), roughness:.95 });
      for (let i=0;i<4;i++) {
        const leaf = new THREE.Mesh(new THREE.SphereGeometry(rand(.9,1.4), 12, 10), leafMat);
        leaf.position.set(rand(-.8,.8), trunkH + rand(.5,1.6), rand(-.8,.8));
        leaf.castShadow = leaf.receiveShadow = true; g.add(leaf);
      }
      g.position.set(x,0,z); scene.add(g); groups.trees.push(g);
    }

    function makeCar(x,z,color){
      const g = new THREE.Group();
      const mat = new THREE.MeshStandardMaterial({ color, metalness:.28, roughness:.55 });
      const hood = new THREE.Mesh(new THREE.BoxGeometry(1.2,.45,1.65), mat); hood.position.set(-.95,.48,0); g.add(hood);
      const cabin = new THREE.Mesh(new THREE.BoxGeometry(1.5,.75,1.55), new THREE.MeshStandardMaterial({ color:'#b9cedd', metalness:.25, roughness:.2 })); cabin.position.set(.2,.86,0); g.add(cabin);
      const trunk = new THREE.Mesh(new THREE.BoxGeometry(1.0,.48,1.65), mat); trunk.position.set(1.35,.52,0); g.add(trunk);
      const wheelGeo = new THREE.CylinderGeometry(.32,.32,.26,16);
      for (const [wx,wz] of [[-1.15,-.74],[-1.15,.74],[1.2,-.74],[1.2,.74]]) {
        const wh = new THREE.Mesh(wheelGeo, new THREE.MeshStandardMaterial({ color:'#191919', roughness:1 }));
        wh.rotation.z = Math.PI/2; wh.position.set(wx,.28,wz); wh.castShadow = true; g.add(wh);
      }
      g.position.set(x,0,z); g.traverse(o=>{ if(o.isMesh){ o.castShadow = o.receiveShadow = true; }}); scene.add(g);
    }

    function makeFenceRow(x,z,len,chain=false){
      for (let i=0;i<len;i++) {
        const p = new THREE.Mesh(new THREE.BoxGeometry(.08,.9,.08), new THREE.MeshStandardMaterial({ color: chain ? '#808890' : '#c8ac87', roughness:.95 }));
        p.position.set(x+i*.58,.45,z); p.castShadow = true; scene.add(p);
        if (!chain) {
          const rail = new THREE.Mesh(new THREE.BoxGeometry(.56,.05,.06), new THREE.MeshStandardMaterial({ color:'#d5bb98', roughness:.95 }));
          rail.position.set(x+i*.58,.62,z); rail.castShadow = true; scene.add(rail);
        }
      }
    }

    function makeMailbox(x,z){
      const post = new THREE.Mesh(new THREE.BoxGeometry(.1,1.05,.1), new THREE.MeshStandardMaterial({ color:'#7a5b44' }));
      const box = new THREE.Mesh(new THREE.BoxGeometry(.55,.35,.35), new THREE.MeshStandardMaterial({ color:'#ccd4db', roughness:.6 }));
      post.position.set(x,.52,z); box.position.set(x,1.0,z); post.castShadow = box.castShadow = true; scene.add(post,box);
    }

    function makeStreetLight(x,z){
      const pole = new THREE.Mesh(new THREE.CylinderGeometry(.08,.11,7.6,10), new THREE.MeshStandardMaterial({ color:'#4f555c', roughness:.9 }));
      pole.position.set(x,3.8,z); pole.castShadow = true; scene.add(pole);
      const arm = new THREE.Mesh(new THREE.BoxGeometry(1.2,.08,.08), new THREE.MeshStandardMaterial({ color:'#4f555c' }));
      arm.position.set(x+.55,7.4,z); scene.add(arm);
    }

    function makeHydrant(x,z){
      const base = new THREE.Mesh(new THREE.CylinderGeometry(.24,.27,.55,12), new THREE.MeshStandardMaterial({ color:'#d4342b', roughness:.7 }));
      const top = new THREE.Mesh(new THREE.SphereGeometry(.18,12,10), new THREE.MeshStandardMaterial({ color:'#c92a20', roughness:.65 }));
      base.position.set(x,.28,z); top.position.set(x,.62,z); base.castShadow = top.castShadow = true; scene.add(base,top);
    }

    function makePet(x,z,type='dog'){
      const g = new THREE.Group();
      if (type === 'dog') {
        g.add(new THREE.Mesh(new THREE.BoxGeometry(1.2,.55,.4), new THREE.MeshStandardMaterial({ color:'#9c744e' })));
        const head = new THREE.Mesh(new THREE.BoxGeometry(.42,.36,.34), new THREE.MeshStandardMaterial({ color:'#ab8259' })); head.position.set(.74,.2,0); g.add(head);
      } else {
        g.add(new THREE.Mesh(new THREE.BoxGeometry(.45,.24,.2), new THREE.MeshStandardMaterial({ color:'#59504c' })));
        const tail = new THREE.Mesh(new THREE.BoxGeometry(.06,.2,.06), new THREE.MeshStandardMaterial({ color:'#59504c' })); tail.position.set(-.26,.16,0); g.add(tail);
      }
      for (let i=0;i<4;i++) { const leg = new THREE.Mesh(new THREE.BoxGeometry(.1,.28,.1), new THREE.MeshStandardMaterial({ color:'#7d5c40' })); leg.position.set(i<2?-.3:.3,-.26,i%2?-.11:.11); g.add(leg); }
      g.position.set(x,.58,z); g.traverse(o=>{ if(o.isMesh) o.castShadow=true; }); scene.add(g); return g;
    }

    // place neighborhood
    const carColors = ['#c95f52','#5474cb','#58a266','#e0b247','#8c6fc0','#2e8f9a'];
    for (let i=0;i<18;i++) {
      const x = -150 + i*18;
      makeHouse(x, -22 - (i%3)*1.2, i);
      makeHouse(x+7, 22 + ((i+1)%3)*1.1, i+3);
      makeTree(x+rand(-3,3), -30-rand(0,2));
      makeTree(x+rand(-3,3), 30+rand(0,2));
      makeFenceRow(x-3, -14.5, 9, i%2===0);
      makeFenceRow(x-3, 14.5, 9, i%2===1);
      makeMailbox(x+2.4, -9.8);
      makeMailbox(x+1.5, 9.8);
      if (i%2===0) makeStreetLight(x+4, i%4===0?-8.8:8.8);
      if (i<14) makeCar(x+5, (i%2===0)?-10.4:10.4, carColors[i%carColors.length]);
    }
    makeHydrant(-3, -9.4);
    const dog = makePet(31,-15.8,'dog');
    const cat = makePet(22,15.3,'cat');

    // power lines
    const lineMat = new THREE.LineBasicMaterial({ color:'#2f3134', transparent:true, opacity:.52 });
    const poles = [];
    for (let i=0;i<20;i++) {
      const x = -160 + i*17;
      for (const z of [-29,29]) {
        const pole = new THREE.Mesh(new THREE.CylinderGeometry(.11,.15,8.2,9), new THREE.MeshStandardMaterial({ color:'#594736', roughness:.95 }));
        pole.position.set(x,4.1,z); pole.castShadow = true; scene.add(pole);
      }
      poles.push(x);
    }
    for (const z of [-29,29]) {
      for (let c=0;c<3;c++) {
        const pts = poles.map((x,i)=>new THREE.Vector3(x,7.2-c*.33 - Math.sin(i*.5+c)*.18,z));
        scene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), lineMat));
      }
    }

    // birds, leaves, dust, sprinkler
    for (let i=0;i<9;i++) {
      const bird = new THREE.Group();
      const wing = new THREE.Mesh(new THREE.ConeGeometry(.16,.45,3), new THREE.MeshBasicMaterial({ color:'#3f312a' }));
      wing.rotation.z = Math.PI/2; wing.position.x = -.16;
      const wingR = wing.clone(); wingR.position.x = .16;
      bird.add(wing, wingR);
      bird.position.set(rand(-50,50), rand(13,19), rand(-10,10));
      scene.add(bird); groups.birds.push({ bird, seed:i });
    }

    const leafGeo = new THREE.BufferGeometry(); const leafCount = 260; const leafPos = new Float32Array(leafCount*3); const leafVel=[];
    for (let i=0;i<leafCount;i++){ leafPos[i*3]=rand(-170,170); leafPos[i*3+1]=rand(.3,5.5); leafPos[i*3+2]=rand(-40,40); leafVel.push(rand(.5,1.4)); }
    leafGeo.setAttribute('position', new THREE.BufferAttribute(leafPos,3));
    const leaves = new THREE.Points(leafGeo, new THREE.PointsMaterial({ color:'#f5bb63', size:.11, opacity:.58, transparent:true, depthWrite:false, blending:THREE.AdditiveBlending }));
    scene.add(leaves);

    const dustGeo = new THREE.BufferGeometry(); const dustCount = 420; const dustPos = new Float32Array(dustCount*3); const dustVel=[];
    for (let i=0;i<dustCount;i++){ dustPos[i*3]=rand(-180,180); dustPos[i*3+1]=rand(.7,12); dustPos[i*3+2]=rand(-45,45); dustVel.push(rand(.04,.16)); }
    dustGeo.setAttribute('position', new THREE.BufferAttribute(dustPos,3));
    const dust = new THREE.Points(dustGeo, new THREE.PointsMaterial({ color:'#ffe8c2', size:.08, opacity:.36, transparent:true, depthWrite:false, blending:THREE.AdditiveBlending }));
    scene.add(dust);

    const sprinkler = new THREE.Group();
    sprinkler.position.set(12,.2,-12.5);
    const sprBase = new THREE.Mesh(new THREE.CylinderGeometry(.08,.1,.2,8), new THREE.MeshStandardMaterial({ color:'#6a6f74' })); sprBase.position.y=.1; sprinkler.add(sprBase);
    const sprayGeo = new THREE.BufferGeometry(); const sprayCount=120; const spray = new Float32Array(sprayCount*3);
    for (let i=0;i<sprayCount;i++){ spray[i*3]=Math.random()*2.2; spray[i*3+1]=Math.random()*1.2; spray[i*3+2]=(Math.random()-.5)*.28; }
    sprayGeo.setAttribute('position', new THREE.BufferAttribute(spray,3));
    const sprayPts = new THREE.Points(sprayGeo, new THREE.PointsMaterial({ color:'#c7ecff', size:.04, opacity:.65, transparent:true }));
    sprinkler.add(sprayPts); scene.add(sprinkler);

    // Character + animation manager
    const loader = new AssetLoader({ manifestPath: '../assets/manifest.json' });
    const soldierGLTF = await loader.loadAsset('soldier-main', { clone:false });
    const soldier = soldierGLTF.scene;
    soldier.scale.setScalar(1.34);
    soldier.position.set(-130,0,0);
    soldier.rotation.y = -Math.PI/2;
    soldier.traverse(o=>{ if(o.isMesh){ o.castShadow = o.receiveShadow = true; }});
    scene.add(soldier);

    const anim = new AnimationManager(soldier);
    const walkClip = soldierGLTF.animations.find(a => /walk/i.test(a.name)) || soldierGLTF.animations[0];
    const idleClip = soldierGLTF.animations.find(a => /idle/i.test(a.name)) || soldierGLTF.animations[1] || soldierGLTF.animations[0];
    anim.clips.set('Walk', walkClip); anim.clips.set('Idle', idleClip);
    const walkAction = anim.mixer.clipAction(walkClip, soldier); walkAction.enabled = true; walkAction.timeScale = 1.05; anim.actions.set('Walk', walkAction);
    const idleAction = anim.mixer.clipAction(idleClip, soldier); idleAction.enabled = true; anim.actions.set('Idle', idleAction);
    anim.defineMarkers('Walk', [
      { type:'footstep', time: walkClip.duration * 0.12 },
      { type:'footstep', time: walkClip.duration * 0.62 }
    ]);
    anim.play('Walk', { fadeIn: 0.4 });

    // Camera rail + post
    const post = new PostStack(renderer, scene, camera);
    post.setAnamorphic({ intensity:0.10, threshold:0.88, stretch:1.6 });
    post.setBloom({ strength:0.45, radius:0.35, threshold:0.38 });
    post.setLetterbox({ enabled:true, height:0.092 });

    const rail = new CameraRail(camera, { profile:'dolly' });
    rail.setControlPoints([
      [-150, 20, 58], [-100, 13, 30], [-55, 7, 12], [-6, 2.6, 6.2],
      [18, 2.3, 4.6], [42, 3.6, 8.0], [72, 10.5, 17.5], [120, 18, 32]
    ]);

    rail.setSequence([
      { duration:7.5, from:0.0, to:0.22, lens:'24mm', operator:'dolly', easing:'easeInOutSine', grading:{ exposure:0.95, contrast:1.04, saturation:1.02, tint:'#fff5e5' }, dof:{ aperture:0.008, maxBlur:0.004 } },
      { duration:8.0, from:0.22, to:0.52, lens:'50mm', operator:'dolly', easing:'easeInOutCubic', grading:{ exposure:0.97, contrast:1.05, saturation:1.03, tint:'#ffe7c8' }, dof:{ aperture:0.010, maxBlur:0.005 } },
      { duration:5.0, from:0.52, to:0.62, lens:'85mm', operator:'dolly', easing:'easeInOutSine', grading:{ exposure:0.98, contrast:1.03, saturation:0.98, tint:'#ffd9b0' }, dof:{ aperture:0.012, maxBlur:0.006 } },
      { duration:9.5, from:0.62, to:1.0, lens:'35mm', operator:'crane', easing:'easeInOutCubic', grading:{ exposure:0.96, contrast:1.06, saturation:1.02, tint:'#ffe1be' }, dof:{ aperture:0.008, maxBlur:0.004 } }
    ]);

    // Story timing
    const story = { pauseAt: 13.8, pauseDur: 4.6, startX: -130, speed: 6.1, resumed:false, showTitle:false };
    const lookPoint = new THREE.Vector3(10, 2.2, 0.6);

    // WebAudio
    const AC = window.AudioContext || window.webkitAudioContext;
    const audio = AC ? new AC() : null;
    let audioReady = false;
    let footBus = null;

    function noiseBuffer(seconds=2){
      const buf = audio.createBuffer(1, audio.sampleRate*seconds, audio.sampleRate);
      const d = buf.getChannelData(0); for(let i=0;i<d.length;i++) d[i] = Math.random()*2-1; return buf;
    }

    function setupAudio(){
      if (!audio || audioReady) return;
      audioReady = true;
      const master = audio.createGain(); master.gain.value = 0.22; master.connect(audio.destination);

      const wind = audio.createBufferSource(); wind.buffer = noiseBuffer(3); wind.loop=true;
      const windFilt = audio.createBiquadFilter(); windFilt.type='bandpass'; windFilt.frequency.value = 520; windFilt.Q.value=.4;
      const windGain = audio.createGain(); windGain.gain.value=.027;
      wind.connect(windFilt).connect(windGain).connect(master); wind.start();

      const distant = audio.createOscillator(); distant.type='sawtooth'; distant.frequency.value = 94;
      const dLP = audio.createBiquadFilter(); dLP.type='lowpass'; dLP.frequency.value = 250;
      const dGain = audio.createGain(); dGain.gain.value=.012;
      distant.connect(dLP).connect(dGain).connect(master); distant.start();

      // birds spatial
      function chirp() {
        const t = audio.currentTime + Math.random()*0.08;
        const o = audio.createOscillator(); o.type='triangle';
        o.frequency.setValueAtTime(rand(1250,1800), t);
        o.frequency.exponentialRampToValueAtTime(rand(1900,2600), t+.06);
        const g = audio.createGain(); g.gain.setValueAtTime(.0001, t); g.gain.exponentialRampToValueAtTime(rand(.01,.02), t+.018); g.gain.exponentialRampToValueAtTime(.0001, t+.16);
        const pan = audio.createStereoPanner(); pan.pan.value = rand(-.95,.95);
        o.connect(g).connect(pan).connect(master); o.start(t); o.stop(t+.2);
      }
      (function loopBird(){ if(!audioReady) return; chirp(); if (Math.random()>.4) chirp(); setTimeout(loopBird, 1200 + Math.random()*2200); })();

      // soft musical swell for pause beat
      const pad = audio.createOscillator(); pad.type='sine'; pad.frequency.value = 220;
      const padGain = audio.createGain(); padGain.gain.value = 0.0001;
      pad.connect(padGain).connect(master); pad.start();
      story.musicGain = padGain;

      footBus = audio.createGain(); footBus.gain.value=.32; footBus.connect(master);
      hint.style.opacity = 0;
    }

    function playFootstep(){
      if(!audioReady || !footBus) return;
      const t = audio.currentTime;
      const n = audio.createBufferSource(); n.buffer = noiseBuffer(.2);
      const nf = audio.createBiquadFilter(); nf.type='bandpass'; nf.frequency.value = 210;
      const ng = audio.createGain(); ng.gain.setValueAtTime(.0001,t); ng.gain.exponentialRampToValueAtTime(.03,t+.013); ng.gain.exponentialRampToValueAtTime(.0001,t+.11);
      const th = audio.createOscillator(); th.type='sine'; th.frequency.setValueAtTime(84,t); th.frequency.exponentialRampToValueAtTime(54,t+.08);
      const tg = audio.createGain(); tg.gain.setValueAtTime(.0001,t); tg.gain.exponentialRampToValueAtTime(.018,t+.01); tg.gain.exponentialRampToValueAtTime(.0001,t+.1);
      n.connect(nf).connect(ng).connect(footBus); th.connect(tg).connect(footBus);
      n.start(t); n.stop(t+.12); th.start(t); th.stop(t+.12);
    }

    addEventListener('pointerdown', async () => {
      if (!audio) return;
      if (audio.state === 'suspended') await audio.resume();
      setupAudio();
    }, { once:true });

    const clock = new THREE.Clock();

    function animate(){
      const dt = Math.min(clock.getDelta(), 0.033);
      const t = clock.elapsedTime;

      // character blocking
      const inPause = t > story.pauseAt && t < story.pauseAt + story.pauseDur;
      if (inPause) {
        if (anim.getState() !== 'Idle') anim.crossfadeTo('Idle', 0.55);
        soldier.rotation.y = -Math.PI/2 + Math.sin((t-story.pauseAt)*0.8)*0.12;
        if (story.musicGain) {
          story.musicGain.gain.setTargetAtTime(0.035, audio.currentTime, 0.8);
          story.musicGain.gain.setTargetAtTime(0.0001, audio.currentTime + 2.2, 1.8);
        }
      } else {
        if (anim.getState() !== 'Walk') anim.crossfadeTo('Walk', 0.45);
        soldier.position.x += dt * story.speed;
        soldier.position.z = Math.sin(t*0.55)*0.08;
        soldier.rotation.y = -Math.PI/2;
      }

      if (soldier.position.x > 140) soldier.position.x = story.startX;

      anim.update(dt, (ev)=>{ if(ev.type === 'footstep' && !inPause) playFootstep(); });

      // focus pulls: intimate on soldier, then hold on human moment point
      if (inPause) {
        rail.setFocusPoint(lookPoint);
      } else {
        rail.setFocusPoint([soldier.position.x + 2.4, 1.55, soldier.position.z]);
      }
      rail.update(t, post);

      // ambient life
      key.intensity = 1.55 + Math.sin(t*0.25)*0.08;
      fill.intensity = 0.66 + Math.sin(t*0.33 + 1.1)*0.04;
      post.setBloom({ strength: 0.42 + Math.sin(t*0.4)*0.04 });

      const lp = leaves.geometry.attributes.position;
      for(let i=0;i<leafCount;i++){
        const ix=i*3, iy=ix+1, iz=ix+2;
        lp.array[ix]+=dt*leafVel[i]*0.9;
        lp.array[iy]+=Math.sin(t*1.8+i)*dt*0.18;
        lp.array[iz]+=Math.cos(t*1.2+i*.3)*dt*0.3;
        if (lp.array[ix] > 180) { lp.array[ix] = -180; lp.array[iy]=rand(.2,5.8); lp.array[iz]=rand(-42,42); }
      }
      lp.needsUpdate = true;

      const dp = dust.geometry.attributes.position;
      for(let i=0;i<dustCount;i++){
        const ix=i*3, iy=ix+1;
        dp.array[iy]+=dustVel[i]*dt;
        dp.array[ix]+=Math.sin(t*.23+i)*dt*.04;
        if(dp.array[iy] > 13) dp.array[iy]=.7;
      }
      dp.needsUpdate = true;

      for (const { bird, seed } of groups.birds) {
        const ph = t*0.8 + seed;
        bird.position.x += dt * (0.85 + (seed%3)*0.1);
        if (bird.position.x > 165) bird.position.x = -165;
        bird.position.y = 14 + Math.sin(ph)*1.7 + (seed%4)*0.32;
        bird.position.z = Math.cos(ph*0.7)*4.5;
        bird.children[0].rotation.y = Math.sin(ph*8.4)*0.9;
        bird.children[1].rotation.y = -Math.sin(ph*8.4)*0.9;
      }

      dog.position.x = 31 + Math.sin(t*0.4)*0.6;
      dog.rotation.y = Math.sin(t*0.9)*0.25;
      cat.position.y = 0.58 + Math.sin(t*1.8)*0.02;

      sprinkler.rotation.y = Math.sin(t*0.7)*0.45;
      sprayPts.material.opacity = 0.45 + Math.sin(t*2.2)*0.2;

      if (t > 24.5 && !story.showTitle) {
        story.showTitle = true;
        titleCard.style.opacity = 1;
      }

      post.render(dt, t);
      requestAnimationFrame(animate);
    }

    animate();

    addEventListener('resize', ()=>{
      camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight); post.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>
