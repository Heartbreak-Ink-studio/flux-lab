<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>DATE CAFE — v2</title>
  <style>
    html, body { margin:0; width:100%; height:100%; overflow:hidden; background:#171311; }
    #app { width:100%; height:100%; }
    .ui { position:fixed; z-index:5; pointer-events:none; font:11px monospace; letter-spacing:.12em; color:rgba(255,228,205,.65); }
    #subtitle { left:50%; bottom:16px; transform:translateX(-50%); }
    #back { pointer-events:auto; position:fixed; left:16px; top:16px; z-index:6; color:#e7b28f; border:1px solid rgba(231,178,143,.35); text-decoration:none; font:11px monospace; letter-spacing:.1em; padding:6px 10px; background:rgba(20,14,12,.7); border-radius:4px; }
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <a id="back" href="../">← GALLERY</a>
  <div id="app"></div>
  <div id="subtitle" class="ui">DATE CAFE — stable camera, warmer room, gentle rain</div>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { BokehPass } from 'three/addons/postprocessing/BokehPass.js';

    const SET = {
      loop: 24,
      exposure: 0.92,
      bloom: 0.36,
      dofAperture: 0.008,
      dofMaxBlur: 0.004,
      room: { w: 14, d: 10, h: 4.2 }
    };

    const app = document.getElementById('app');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color('#231b17');
    scene.fog = new THREE.Fog('#2b221d', 8, 24);

    const camera = new THREE.PerspectiveCamera(38, innerWidth / innerHeight, 0.1, 100);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(2, devicePixelRatio));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = SET.exposure;
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    app.appendChild(renderer.domElement);

    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    const bloom = new UnrealBloomPass(new THREE.Vector2(innerWidth, innerHeight), SET.bloom, 0.28, 0.82);
    composer.addPass(bloom);
    const bokeh = new BokehPass(scene, camera, {
      focus: 3.2,
      aperture: SET.dofAperture,
      maxblur: SET.dofMaxBlur,
      width: innerWidth,
      height: innerHeight
    });
    composer.addPass(bokeh);

    const LIGHT = {
      hemi: new THREE.HemisphereLight('#f5d7be', '#698197', 0.22),
      key: new THREE.SpotLight('#ffd1a3', 1.75, 30, 0.8, 0.45, 1.3),
      fill: new THREE.SpotLight('#a7bfd4', 0.82, 30, 0.95, 0.6, 1.0),
      rim: new THREE.DirectionalLight('#9ac3da', 0.9)
    };
    LIGHT.key.position.set(-4.8, 3.8, -3.5);
    LIGHT.key.target.position.set(0.1, 1.1, -0.3);
    LIGHT.key.castShadow = true;
    LIGHT.key.shadow.mapSize.set(1024,1024);
    LIGHT.key.shadow.bias = -0.0003;
    LIGHT.fill.position.set(4.4, 2.8, 2.8);
    LIGHT.fill.target.position.set(0.2, 1.0, -0.2);
    LIGHT.rim.position.set(2.4, 3.2, -4.6);
    scene.add(LIGHT.hemi, LIGHT.key, LIGHT.key.target, LIGHT.fill, LIGHT.fill.target, LIGHT.rim);

    function mat(color, rough=0.6, metal=0.05) { return new THREE.MeshStandardMaterial({ color, roughness: rough, metalness: metal }); }

    const room = new THREE.Group();
    const floor = new THREE.Mesh(new THREE.PlaneGeometry(SET.room.w, SET.room.d), mat('#6b4f3e', 0.56));
    floor.rotation.x = -Math.PI/2; floor.receiveShadow = true; room.add(floor);
    const back = new THREE.Mesh(new THREE.PlaneGeometry(SET.room.w, SET.room.h), mat('#7f6b5b', 0.72));
    back.position.set(0, SET.room.h/2, -SET.room.d/2); back.receiveShadow = true; room.add(back);
    const left = new THREE.Mesh(new THREE.PlaneGeometry(SET.room.d, SET.room.h), mat('#69574a', 0.74));
    left.position.set(-SET.room.w/2, SET.room.h/2, 0); left.rotation.y = Math.PI/2; room.add(left);
    const right = left.clone(); right.position.x = SET.room.w/2; right.rotation.y = -Math.PI/2; room.add(right);
    scene.add(room);

    // Window wall + rain
    const winGroup = new THREE.Group();
    const frameM = mat('#3a2d25', 0.6, 0.12);
    const winX0 = -4.0, winY = 2.3, winZ = -4.8;
    const frame = new THREE.Mesh(new THREE.BoxGeometry(5.0, 2.8, 0.08), frameM);
    frame.position.set(winX0, winY, winZ); winGroup.add(frame);
    const glass = new THREE.Mesh(new THREE.PlaneGeometry(4.72, 2.5), new THREE.MeshPhysicalMaterial({ color:'#9db2be', transparent:true, opacity:0.2, roughness:0.08, metalness:0, transmission:0.45 }));
    glass.position.set(winX0, winY, winZ + 0.05); winGroup.add(glass);
    [-1.56,0,1.56].forEach(dx => {
      const mull = new THREE.Mesh(new THREE.BoxGeometry(0.06, 2.56, 0.1), frameM);
      mull.position.set(winX0 + dx, winY, winZ + 0.04); winGroup.add(mull);
    });
    scene.add(winGroup);

    const rainGeo = new THREE.BufferGeometry();
    const count = 420;
    const pos = new Float32Array(count * 3);
    const vel = new Float32Array(count);
    for (let i=0; i<count; i++) {
      pos[i*3] = THREE.MathUtils.randFloat(-6.4, -1.6);
      pos[i*3+1] = THREE.MathUtils.randFloat(1.0, 4.3);
      pos[i*3+2] = THREE.MathUtils.randFloat(-5.9, -5.1);
      vel[i] = THREE.MathUtils.randFloat(1.3, 2.4);
    }
    rainGeo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    const rain = new THREE.Points(rainGeo, new THREE.PointsMaterial({ size:0.02, color:'#bcd4e2', transparent:true, opacity:0.4, depthWrite:false }));
    scene.add(rain);

    // Bar / door / props for depth
    const bar = new THREE.Mesh(new THREE.BoxGeometry(4.0, 1.1, 0.9), mat('#4f3a2d', 0.5));
    bar.position.set(4.5, 0.55, -1.8); bar.castShadow = bar.receiveShadow = true; scene.add(bar);
    for (let i=0;i<9;i++) {
      const b = new THREE.Mesh(new THREE.CylinderGeometry(0.06,0.06,0.35,10), mat(i%2?'#90adbe':'#bda28a',0.2,0.02));
      b.position.set(3.2 + (i%3)*0.5, 1.4 + Math.floor(i/3)*0.35, -2.1);
      scene.add(b);
    }
    const chalk = new THREE.Mesh(new THREE.PlaneGeometry(1.0, 1.3), mat('#1d2423', 0.8));
    chalk.position.set(2.95, 1.2, -2.35); chalk.rotation.y = -0.25; scene.add(chalk);
    const door = new THREE.Mesh(new THREE.BoxGeometry(1.3, 2.6, 0.08), mat('#3a2b22',0.6));
    door.position.set(5.8, 1.3, -4.68); scene.add(door);

    // Table + chairs + hero props
    const table = new THREE.Group();
    const tTop = new THREE.Mesh(new THREE.CylinderGeometry(0.62,0.62,0.06,36), mat('#6c4d3b',0.5));
    tTop.position.y = 0.76;
    const tLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.08,0.11,0.7,18), mat('#2b2f33',0.35,0.5));
    tLeg.position.y = 0.39;
    const tBase = new THREE.Mesh(new THREE.CylinderGeometry(0.28,0.32,0.05,18), mat('#2a2a2c',0.4,0.5));
    tBase.position.y = 0.02;
    table.add(tTop,tLeg,tBase); table.position.set(0.2,0,-0.2);
    table.traverse(o=>{ if (o.isMesh) { o.castShadow = o.receiveShadow = true; }});
    scene.add(table);

    function chair(x,z,yRot){
      const g = new THREE.Group();
      const m = mat('#533e30',0.58);
      const s = new THREE.Mesh(new THREE.BoxGeometry(0.66,0.06,0.62),m); s.position.y=0.48;
      const b = new THREE.Mesh(new THREE.BoxGeometry(0.66,0.75,0.05),m); b.position.set(0,0.86,-0.28);
      g.add(s,b);
      [[.28,.24,.24],[-.28,.24,.24],[.28,.24,-.24],[-.28,.24,-.24]].forEach(([lx,ly,lz])=>{
        const l = new THREE.Mesh(new THREE.BoxGeometry(0.05,0.48,0.05),m); l.position.set(lx,ly,lz); g.add(l);
      });
      g.position.set(x,0,z); g.rotation.y=yRot; g.traverse(o=>{ if (o.isMesh){o.castShadow=true;o.receiveShadow=true;}}); scene.add(g);
    }
    chair(-0.55,0.58,Math.PI); chair(0.68,0.45,0);

    function cup(x,z){ const c = new THREE.Mesh(new THREE.CylinderGeometry(0.08,0.09,0.11,16), mat('#d8c9bb',0.25)); c.position.set(x,0.845,z); c.castShadow=true; scene.add(c); }
    cup(-0.03,-0.16); cup(0.45,-0.1);
    const pot = new THREE.Mesh(new THREE.SphereGeometry(0.1,16,16), mat('#b8a493',0.3)); pot.position.set(0.2,0.84,-0.28); pot.castShadow=true; scene.add(pot);
    const sugar = new THREE.Mesh(new THREE.CylinderGeometry(0.06,0.06,0.12,16), mat('#cfd5da',0.12)); sugar.position.set(0.34,0.84,-0.33); scene.add(sugar);
    const napkin = new THREE.Mesh(new THREE.BoxGeometry(0.12,0.06,0.12), mat('#9f7867',0.7)); napkin.position.set(0.07,0.82,-0.31); scene.add(napkin);
    const menu = new THREE.Mesh(new THREE.BoxGeometry(0.12,0.18,0.01), mat('#efe2c8',0.7)); menu.position.set(0.04,0.87,0.08); menu.rotation.y=0.2; scene.add(menu);
    const vase = new THREE.Mesh(new THREE.CylinderGeometry(0.03,0.04,0.12,10), mat('#9eb8bf',0.15)); vase.position.set(0.22,0.85,0.05); scene.add(vase);

    // FG occluders
    function plant(x,z,s=1){
      const p = new THREE.Group();
      const pot = new THREE.Mesh(new THREE.CylinderGeometry(0.16*s,0.2*s,0.25*s,12), mat('#4e3b31',0.62));
      const leafM = mat('#4e765b',0.7);
      p.add(pot);
      for (let i=0;i<5;i++) {
        const leaf = new THREE.Mesh(new THREE.SphereGeometry(0.09*s,8,8), leafM);
        leaf.scale.set(0.9,1.5,0.6);
        leaf.position.set((Math.random()-.5)*0.2*s,0.2*s+Math.random()*0.15*s,(Math.random()-.5)*0.2*s);
        p.add(leaf);
      }
      p.position.set(x,0,z); p.traverse(o=>{if(o.isMesh){o.castShadow=true;o.receiveShadow=true;}}); scene.add(p);
    }
    plant(-5.8,2.4,1.3); plant(5.6,2.2,1.1); // foreground frame
    plant(-5.4,-4.6,0.65); plant(-3.5,-4.65,0.55); // window sill plants

    // Pendant lights
    [-2,0,2].forEach(x => {
      const bulb = new THREE.PointLight('#ffca8a', 0.55, 6, 1.9);
      bulb.position.set(x,3.2,-0.8);
      const shade = new THREE.Mesh(new THREE.ConeGeometry(0.22,0.25,16), mat('#3b2d25',0.4,0.12));
      shade.position.copy(bulb.position); shade.rotation.x = Math.PI;
      scene.add(bulb, shade);
    });

    // Characters
    const loader = new GLTFLoader();
    const rabbitGltf = await loader.loadAsync('../assets/characters/rabbit-rigged.glb');
    const tortoiseGltf = await loader.loadAsync('../assets/characters/tortoise-rigged.glb');
    const rabbit = rabbitGltf.scene;
    const tortoise = tortoiseGltf.scene;
    rabbit.position.set(-0.55, 0.0, -0.2); rabbit.rotation.y = THREE.MathUtils.degToRad(25); rabbit.scale.setScalar(1.02);
    tortoise.position.set(0.68, 0.0, -0.15); tortoise.rotation.y = THREE.MathUtils.degToRad(-20); tortoise.scale.setScalar(1.05);
    [rabbit,tortoise].forEach(c=>{c.traverse(o=>{if(o.isMesh){o.castShadow=true;o.receiveShadow=true;}}); scene.add(c);});

    // Motion system (always visible movement)
    const mixers = [];
    function playIdle(gltf, root, speed) {
      if (!gltf.animations?.length) return false;
      const mx = new THREE.AnimationMixer(root);
      const clip = gltf.animations.find(a=>/idle|sit|breathe|talk/i.test(a.name)) || gltf.animations[0];
      const action = mx.clipAction(clip); action.play(); action.timeScale = speed;
      mixers.push(mx);
      return true;
    }
    const rabbitHasAnim = playIdle(rabbitGltf, rabbit, 0.9);
    const tortoiseHasAnim = playIdle(tortoiseGltf, tortoise, 0.78);

    function findBone(root, keys) {
      let hit = null;
      root.traverse(o=>{ if (!hit && o.isBone && keys.some(k=>o.name.toLowerCase().includes(k))) hit = o; });
      return hit;
    }
    const rb = { head: findBone(rabbit,['head','neck']), arm: findBone(rabbit,['arm','hand']), chest: findBone(rabbit,['spine','chest']) };
    const tb = { head: findBone(tortoise,['head','neck']), arm: findBone(tortoise,['arm','hand']), chest: findBone(tortoise,['spine','chest','shell']) };

    const SHOTS = [
      { d:4,  p:[-2.8,1.45,3.8],  l:[0.1,1.1,-0.3], fov:38 },
      { d:5,  p:[-1.2,1.35,2.1],  l:[0.05,1.05,-0.2], fov:44 },
      { d:4,  p:[-0.55,1.32,1.1], l:[0.55,1.02,-0.1], fov:50 },
      { d:4,  p:[0.75,1.30,1.15], l:[-0.45,1.04,-0.15], fov:50 },
      { d:5,  p:[-3.4,1.4,0.2],   l:[0.0,1.0,-0.2], fov:35 }
    ];
    const shotTotal = SHOTS.reduce((a,s)=>a+s.d,0);

    function applyCamera(t) {
      let acc = 0, i = 0;
      for (; i<SHOTS.length; i++) {
        if (t < acc + SHOTS[i].d) break;
        acc += SHOTS[i].d;
      }
      const a = SHOTS[i % SHOTS.length];
      const b = SHOTS[(i + 1) % SHOTS.length];
      const local = THREE.MathUtils.smoothstep((t - acc) / a.d, 0, 1);
      camera.position.set(
        THREE.MathUtils.lerp(a.p[0], b.p[0], local),
        THREE.MathUtils.lerp(a.p[1], b.p[1], local),
        THREE.MathUtils.lerp(a.p[2], b.p[2], local)
      );
      const lx = THREE.MathUtils.lerp(a.l[0], b.l[0], local);
      const ly = THREE.MathUtils.lerp(a.l[1], b.l[1], local);
      const lz = THREE.MathUtils.lerp(a.l[2], b.l[2], local);
      camera.lookAt(lx, ly, lz);
      camera.fov = THREE.MathUtils.lerp(a.fov, b.fov, local);
      camera.updateProjectionMatrix();
    }

    const clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      const t = clock.getElapsedTime();
      const dt = clock.getDelta();
      const loopT = t % SET.loop;
      const shotT = loopT % shotTotal;

      mixers.forEach(m=>m.update(dt));

      // beat sheet 0-24s
      const beat = loopT;
      const breatheR = Math.sin(t * 1.7) * 0.02;
      const breatheT = Math.sin(t * 1.2 + 0.6) * 0.015;
      rabbit.position.y = breatheR;
      tortoise.position.y = breatheT;

      if (rb.chest) rb.chest.rotation.x = breatheR * 0.7;
      if (tb.chest) tb.chest.rotation.x = breatheT * 0.8;

      let rabbitGesture = 0, tortoiseNod = 0;
      if (beat > 4 && beat < 8) rabbitGesture = Math.sin((beat-4) * Math.PI/4) * 0.35;
      if (beat > 8 && beat < 12) tortoiseNod = Math.sin((beat-8) * Math.PI/4) * 0.28;
      if (beat > 16 && beat < 20) rabbitGesture += Math.sin((beat-16)*Math.PI*2) * 0.16;

      if (!rabbitHasAnim && rb.arm) rb.arm.rotation.x = -0.3 + rabbitGesture;
      if (!tortoiseHasAnim && tb.arm) tb.arm.rotation.x = -0.12 + tortoiseNod * 0.5;
      if (rb.head) rb.head.rotation.y = 0.08 + Math.sin(t*0.9) * 0.06;
      if (tb.head) tb.head.rotation.y = -0.09 + Math.sin(t*0.65+1.4) * 0.05;
      if (tb.head) tb.head.rotation.x = -0.04 + tortoiseNod * 0.3;

      // shared glance to window 12-16s
      if (beat > 12 && beat < 16) {
        rabbit.lookAt(-3.8, 2.1, -4.8);
        tortoise.lookAt(-3.8, 2.0, -4.8);
      }

      applyCamera(shotT);

      // rain movement + neon sweep reflection
      const arr = rain.geometry.attributes.position.array;
      for (let i=0; i<count; i++) {
        arr[i*3+1] -= vel[i] * dt;
        if (arr[i*3+1] < 0.9) arr[i*3+1] = 4.2;
      }
      rain.geometry.attributes.position.needsUpdate = true;
      glass.emissive = new THREE.Color('#351f28');
      glass.emissiveIntensity = 0.08 + Math.max(0, Math.sin((t/7) * Math.PI * 2)) * 0.12;

      composer.render();
    }
    animate();

    addEventListener('resize', () => {
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
      composer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>
